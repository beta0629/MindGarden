diff --git a/node_modules/react-native-reanimated/Common/cpp/reanimated/LayoutAnimations/LayoutAnimationsProxy.h b/node_modules/react-native-reanimated/Common/cpp/reanimated/LayoutAnimations/LayoutAnimationsProxy.h
index cc09908..bb20abe 100644
--- a/node_modules/react-native-reanimated/Common/cpp/reanimated/LayoutAnimations/LayoutAnimationsProxy.h
+++ b/node_modules/react-native-reanimated/Common/cpp/reanimated/LayoutAnimations/LayoutAnimationsProxy.h
@@ -50,7 +50,7 @@ struct LayoutAnimationsProxy
   mutable std::unordered_map<Tag, int> leastRemoved;
   mutable std::vector<Tag> finishedAnimationTags_;
   std::shared_ptr<LayoutAnimationsManager> layoutAnimationsManager_;
-  ContextContainer::Shared contextContainer_;
+  std::shared_ptr<const ContextContainer> contextContainer_;
   SharedComponentDescriptorRegistry componentDescriptorRegistry_;
   jsi::Runtime &uiRuntime_;
   const std::shared_ptr<UIScheduler> uiScheduler_;
@@ -63,7 +63,7 @@ struct LayoutAnimationsProxy
   LayoutAnimationsProxy(
       std::shared_ptr<LayoutAnimationsManager> layoutAnimationsManager,
       SharedComponentDescriptorRegistry componentDescriptorRegistry,
-      ContextContainer::Shared contextContainer,
+      std::shared_ptr<const ContextContainer> contextContainer,
       jsi::Runtime &uiRuntime,
       const std::shared_ptr<UIScheduler> uiScheduler
 #ifdef ANDROID
diff --git a/node_modules/react-native-reanimated/android/build.gradle b/node_modules/react-native-reanimated/android/build.gradle
index e102f43..57eda3e 100644
--- a/node_modules/react-native-reanimated/android/build.gradle
+++ b/node_modules/react-native-reanimated/android/build.gradle
@@ -73,7 +73,16 @@ def isNewArchitectureEnabled() {
 def resolveReactNativeDirectory() {
     def reactNativeLocation = safeAppExtGet("REACT_NATIVE_NODE_MODULES_DIR", null)
     if (reactNativeLocation != null) {
-        return file(reactNativeLocation)
+        // Handle relative paths - resolve from project root
+        def reactNativeDir = file(reactNativeLocation)
+        if (!reactNativeDir.isAbsolute()) {
+            // Resolve relative path from root project directory
+            def rootProjectDir = project.rootProject.projectDir
+            reactNativeDir = file("${rootProjectDir}/../${reactNativeLocation}")
+        }
+        if (reactNativeDir.exists()) {
+            return reactNativeDir
+        }
     }
 
     // Fallback to node resolver for custom directory structures like monorepos.
@@ -123,7 +132,11 @@ if (isNewArchitectureEnabled()) {
 def reactNativeRootDir = resolveReactNativeDirectory()
 
 def reactProperties = new Properties()
-file("$reactNativeRootDir/ReactAndroid/gradle.properties").withInputStream { reactProperties.load(it) }
+def gradlePropsFile = file("$reactNativeRootDir/ReactAndroid/gradle.properties")
+if (!gradlePropsFile.exists()) {
+    throw new Exception("[Reanimated] ReactAndroid/gradle.properties not found at: ${gradlePropsFile.absolutePath}. REACT_NATIVE_DIR: ${reactNativeRootDir.absolutePath}")
+}
+gradlePropsFile.withInputStream { reactProperties.load(it) }
 
 def REACT_NATIVE_VERSION = reactProperties.getProperty("VERSION_NAME")
 def REACT_NATIVE_MINOR_VERSION = REACT_NATIVE_VERSION.startsWith("0.0.0-") ? 1000 : REACT_NATIVE_VERSION.split("\\.")[1].toInteger()
diff --git a/node_modules/react-native-reanimated/android/build.gradle.bak b/node_modules/react-native-reanimated/android/build.gradle.bak
new file mode 100644
index 0000000..e102f43
--- /dev/null
+++ b/node_modules/react-native-reanimated/android/build.gradle.bak
@@ -0,0 +1,494 @@
+import com.android.Version
+import org.apache.tools.ant.filters.ReplaceTokens
+import org.apache.tools.ant.taskdefs.condition.Os
+import groovy.json.JsonSlurper
+import com.android.build.gradle.tasks.ExternalNativeBuildJsonTask
+
+import javax.inject.Inject
+import java.nio.file.Files
+import java.nio.file.Paths
+
+/**
+ * Finds the path of the installed npm package with the given name using Node's
+ * module resolution algorithm, which searches "node_modules" directories up to
+ * the file system root. This handles various cases, including:
+ *
+ *   - Working in the open-source RN repo:
+ *       Gradle: /path/to/react-native/ReactAndroid
+ *       Node module: /path/to/react-native/node_modules/[package]
+ *
+ *   - Installing RN as a dependency of an app and searching for hoisted
+ *     dependencies:
+ *       Gradle: /path/to/app/node_modules/react-native/ReactAndroid
+ *       Node module: /path/to/app/node_modules/[package]
+ *
+ *   - Working in a larger repo (e.g., Facebook) that contains RN:
+ *       Gradle: /path/to/repo/path/to/react-native/ReactAndroid
+ *       Node module: /path/to/repo/node_modules/[package]
+ *
+ * The search begins at the given base directory (a File object). The returned
+ * path is a string.
+ */
+static def findNodeModulePath(baseDir, packageName) {
+    def basePath = baseDir.toPath().normalize()
+    // Node's module resolution algorithm searches up to the root directory,
+    // after which the base path will be null
+    while (basePath) {
+        def candidatePath = Paths.get(basePath.toString(), "node_modules", packageName)
+        if (candidatePath.toFile().exists()) {
+            return candidatePath.toString()
+        }
+        basePath = basePath.getParent()
+    }
+    return null
+}
+
+def safeExtGet(prop, fallback) {
+    rootProject.ext.has(prop) ? rootProject.ext.get(prop) : fallback
+}
+
+def safeAppExtGet(prop, fallback) {
+    def appProject = rootProject.allprojects.find { it.plugins.hasPlugin('com.android.application') }
+    appProject?.ext?.has(prop) ? appProject.ext.get(prop) : fallback
+}
+
+def resolveBuildType() {
+    Gradle gradle = getGradle()
+    String tskReqStr = gradle.getStartParameter().getTaskRequests()['args'].toString()
+    return tskReqStr.contains('Release') ? 'release' : 'debug'
+}
+
+def isReanimatedExampleApp() {
+    return safeAppExtGet("isReanimatedExampleApp", false)
+}
+
+def isNewArchitectureEnabled() {
+    // To opt-in for the New Architecture, you can either:
+    // - Set `newArchEnabled` to true inside the `gradle.properties` file
+    // - Invoke gradle with `-newArchEnabled=true`
+    // - Set an environment variable `ORG_GRADLE_PROJECT_newArchEnabled=true`
+    return project.hasProperty("newArchEnabled") && project.newArchEnabled == "true"
+}
+
+def resolveReactNativeDirectory() {
+    def reactNativeLocation = safeAppExtGet("REACT_NATIVE_NODE_MODULES_DIR", null)
+    if (reactNativeLocation != null) {
+        return file(reactNativeLocation)
+    }
+
+    // Fallback to node resolver for custom directory structures like monorepos.
+    def reactNativePackage = file(["node", "--print", "require.resolve('react-native/package.json')"].execute(null, rootDir).text.trim())
+    if(reactNativePackage.exists()) {
+        return reactNativePackage.parentFile
+    }
+
+    throw new GradleException(
+        "[Reanimated] Unable to resolve react-native location in node_modules. You should project extension property (in `app/build.gradle`) `REACT_NATIVE_NODE_MODULES_DIR` with path to react-native."
+    )
+}
+
+def getPlaygroundAppName() { // only for the development
+    String playgroundAppName = ""
+    try {
+        rootProject.getSubprojects().forEach({project ->
+            if (project.plugins.hasPlugin("com.android.application")) {
+                var projectCatalogAbsolutePath = project.projectDir.toString().replace("/android/app", "")
+                var slashPosition = projectCatalogAbsolutePath.lastIndexOf("/")
+                playgroundAppName = projectCatalogAbsolutePath.substring(slashPosition + 1)
+            }
+        })
+    } catch (_) {
+        throw new GradleException("[Reanimated] Couldn't determine playground app name.")
+    }
+    return playgroundAppName
+}
+
+def getReanimatedVersion() {
+    def inputFile = file(projectDir.path + '/../package.json')
+    def json = new JsonSlurper().parseText(inputFile.text)
+    return json.version
+}
+
+def toPlatformFileString(String path) {
+  if (Os.isFamily(Os.FAMILY_WINDOWS)) {
+      path = path.replace(File.separatorChar, '/' as char)
+  }
+  return path
+}
+
+if (isNewArchitectureEnabled()) {
+    apply plugin: "com.facebook.react"
+}
+
+def reactNativeRootDir = resolveReactNativeDirectory()
+
+def reactProperties = new Properties()
+file("$reactNativeRootDir/ReactAndroid/gradle.properties").withInputStream { reactProperties.load(it) }
+
+def REACT_NATIVE_VERSION = reactProperties.getProperty("VERSION_NAME")
+def REACT_NATIVE_MINOR_VERSION = REACT_NATIVE_VERSION.startsWith("0.0.0-") ? 1000 : REACT_NATIVE_VERSION.split("\\.")[1].toInteger()
+def REANIMATED_VERSION = getReanimatedVersion()
+def IS_NEW_ARCHITECTURE_ENABLED = isNewArchitectureEnabled()
+def IS_REANIMATED_EXAMPLE_APP = isReanimatedExampleApp()
+
+// Set version for prefab
+version REANIMATED_VERSION
+
+// We download various C++ open-source dependencies into downloads.
+// We then copy both the downloaded code and our custom makefiles and headers into third-party-ndk.
+// After that we build native code from src/main/jni with module path pointing at third-party-ndk.
+
+def customDownloadsDir = System.getenv("REACT_NATIVE_DOWNLOADS_DIR")
+def downloadsDir = customDownloadsDir ? new File(customDownloadsDir) : new File("$buildDir/downloads")
+def thirdPartyNdkDir = new File("$buildDir/third-party-ndk")
+
+def reactNativeThirdParty = new File("$reactNativeRootDir/ReactAndroid/src/main/jni/third-party")
+def reactNativeAndroidDownloadDir = new File("$reactNativeRootDir/ReactAndroid/build/downloads")
+
+def workletsPrefabHeadersDir = project.file("$buildDir/prefab-headers/worklets")
+def reanimatedPrefabHeadersDir = project.file("$buildDir/prefab-headers/reanimated")
+
+def JS_RUNTIME = {
+    // Override JS runtime with environment variable
+    if (System.getenv("JS_RUNTIME")) {
+        return System.getenv("JS_RUNTIME")
+    }
+
+    // Enable V8 runtime if react-native-v8 is installed
+    def v8Project = rootProject.getSubprojects().find { project -> project.name == "react-native-v8" }
+    if (v8Project != null) {
+        return "v8"
+    }
+
+    // Check if Hermes is enabled in app setup
+    def appProject = rootProject.allprojects.find { it.plugins.hasPlugin('com.android.application') }
+    if (appProject?.hermesEnabled?.toBoolean() || appProject?.ext?.react?.enableHermes?.toBoolean()) {
+        return "hermes"
+    }
+
+    // Use JavaScriptCore (JSC) by default
+    return "jsc"
+}.call()
+
+def jsRuntimeDir = {
+    if (JS_RUNTIME == "hermes") {
+        return Paths.get(reactNativeRootDir.path, "sdks", "hermes")
+    } else if (JS_RUNTIME == "v8") {
+        return findProject(":react-native-v8").getProjectDir().getParent()
+    } else {
+        return Paths.get(reactNativeRootDir.path, "ReactCommon", "jsi")
+    }
+}.call()
+
+def reactNativeArchitectures() {
+    def value = project.getProperties().get("reactNativeArchitectures")
+    return value ? value.split(",") : ["armeabi-v7a", "x86", "x86_64", "arm64-v8a"]
+}
+
+buildscript {
+    repositories {
+        google()
+        mavenCentral()
+        maven {
+            url "https://plugins.gradle.org/m2/"
+        }
+    }
+    dependencies {
+        classpath "com.android.tools.build:gradle:8.2.1"
+        classpath "de.undercouch:gradle-download-task:5.6.0"
+        classpath "com.diffplug.spotless:spotless-plugin-gradle:6.25.0"
+    }
+}
+
+if (project == rootProject) {
+    apply from: "spotless.gradle"
+}
+
+apply plugin: "com.android.library"
+apply plugin: "maven-publish"
+apply plugin: "de.undercouch.download"
+
+android {
+    compileSdkVersion safeExtGet("compileSdkVersion", 34)
+
+    def agpVersion = com.android.Version.ANDROID_GRADLE_PLUGIN_VERSION
+    if (agpVersion.tokenize('.')[0].toInteger() >= 7) {
+        namespace "com.swmansion.reanimated"
+    }
+
+    if (rootProject.hasProperty("ndkPath")) {
+        ndkPath rootProject.ext.ndkPath
+    }
+    if (rootProject.hasProperty("ndkVersion")) {
+        ndkVersion rootProject.ext.ndkVersion
+    }
+
+    buildFeatures {
+        prefab true
+        prefabPublishing true
+        buildConfig true
+    }
+
+    prefab {
+        worklets {
+            headers workletsPrefabHeadersDir.absolutePath
+        }
+        reanimated {
+            headers reanimatedPrefabHeadersDir.absolutePath
+        }
+    }
+
+    defaultConfig {
+        minSdkVersion safeExtGet("minSdkVersion", 23)
+        targetSdkVersion safeExtGet("targetSdkVersion", 34)
+        versionCode 1
+        versionName "1.0"
+        buildConfigField("boolean", "IS_NEW_ARCHITECTURE_ENABLED", IS_NEW_ARCHITECTURE_ENABLED.toString())
+        buildConfigField("String", "REANIMATED_VERSION_JAVA", "\"${REANIMATED_VERSION}\"")
+        externalNativeBuild {
+            cmake {
+                arguments "-DANDROID_STL=c++_shared",
+                        "-DREACT_NATIVE_MINOR_VERSION=${REACT_NATIVE_MINOR_VERSION}",
+                        "-DANDROID_TOOLCHAIN=clang",
+                        "-DREACT_NATIVE_DIR=${toPlatformFileString(reactNativeRootDir.path)}",
+                        "-DJS_RUNTIME=${JS_RUNTIME}",
+                        "-DJS_RUNTIME_DIR=${jsRuntimeDir}",
+                        "-DIS_NEW_ARCHITECTURE_ENABLED=${IS_NEW_ARCHITECTURE_ENABLED}",
+                        "-DIS_REANIMATED_EXAMPLE_APP=${IS_REANIMATED_EXAMPLE_APP}",
+                        "-DREANIMATED_VERSION=${REANIMATED_VERSION}",
+                        "-DANDROID_SUPPORT_FLEXIBLE_PAGE_SIZES=ON"
+                abiFilters (*reactNativeArchitectures())
+                targets("reanimated", "worklets")
+            }
+        }
+
+        buildConfigField("boolean", "IS_INTERNAL_BUILD", "false")
+        buildConfigField("int", "EXOPACKAGE_FLAGS", "0")
+        buildConfigField("int", "REACT_NATIVE_MINOR_VERSION", REACT_NATIVE_MINOR_VERSION.toString())
+
+        consumerProguardFiles 'proguard-rules.pro'
+    }
+    externalNativeBuild {
+        cmake {
+            version = System.getenv("CMAKE_VERSION") ?: "3.22.1"
+            path "CMakeLists.txt"
+        }
+    }
+    buildTypes {
+        debug {
+            externalNativeBuild {
+                cmake {
+                    if (JS_RUNTIME == "hermes") {
+                        //  React Native doesn't expose these flags, but not having them
+                        //  can lead to runtime errors due to ABI mismatches.
+                        //  There's also
+                        //    HERMESVM_PROFILER_OPCODE
+                        //    HERMESVM_PROFILER_BB
+                        //  which shouldn't be defined in standard setups.
+                        arguments "-DHERMES_ENABLE_DEBUGGER=1"
+                    }
+                }
+            }
+        }
+    }
+    lintOptions {
+        abortOnError false
+    }
+    packagingOptions {
+        doNotStrip resolveBuildType() == 'debug' ? "**/**/*.so" : ''
+        // For some reason gradle only complains about the duplicated version of librrc_root and libreact_render libraries
+        // while there are more libraries copied in intermediates folder of the lib build directory, we exclude
+        // only the ones that make the build fail (ideally we should only include libreanimated but we
+        // are only allowed to specify exclude patterns)
+        excludes = [
+                "META-INF",
+                "META-INF/**",
+                "**/libc++_shared.so",
+                "**/libfbjni.so",
+                "**/libjsi.so",
+                "**/libfolly_json.so",
+                "**/libfolly_runtime.so",
+                "**/libglog.so",
+                "**/libhermes.so",
+                "**/libhermes-executor-debug.so",
+                "**/libhermes_executor.so",
+                "**/libhermestooling.so",
+                "**/libreactnativejni.so",
+                "**/libturbomodulejsijni.so",
+                "**/libreactnative.so",
+                "**/libreact_nativemodule_core.so",
+                "**/libreact_render*.so",
+                "**/librrc_root.so",
+                "**/libjscexecutor.so",
+                "**/libv8executor.so",
+        ]
+    }
+    tasks.withType(JavaCompile) {
+        compileTask ->
+            compileTask.dependsOn(packageNdkLibs)
+    }
+    configurations {
+        extractHeaders
+        extractSO
+    }
+    compileOptions {
+        sourceCompatibility JavaVersion.VERSION_17
+        targetCompatibility JavaVersion.VERSION_17
+    }
+    sourceSets.main {
+        java {
+            if (IS_NEW_ARCHITECTURE_ENABLED) {
+                srcDirs += "src/fabric/java"
+            } else {
+                srcDirs += "src/paper/java"
+            }
+
+            // BorderRadiiDrawableUtils
+            if (REACT_NATIVE_MINOR_VERSION <= 75) {
+                srcDirs += "src/reactNativeVersionPatch/BorderRadiiDrawableUtils/75"
+            } else if (REACT_NATIVE_MINOR_VERSION <= 79) {
+                srcDirs += "src/reactNativeVersionPatch/BorderRadiiDrawableUtils/79"
+            } else {
+                srcDirs += "src/reactNativeVersionPatch/BorderRadiiDrawableUtils/latest"
+            }
+
+            // ReanimatedNativeHierarchyManager
+            if (REACT_NATIVE_MINOR_VERSION <= 75) {
+                srcDirs += "src/reactNativeVersionPatch/ReanimatedNativeHierarchyManager/75"
+            } else {
+                srcDirs += "src/reactNativeVersionPatch/ReanimatedNativeHierarchyManager/latest"
+            }
+        }
+    }
+    tasks.withType(ExternalNativeBuildJsonTask) {
+        compileTask ->
+            compileTask.doLast {
+                if (!IS_REANIMATED_EXAMPLE_APP) {
+                    return
+                }
+                def monorepoDir = new File("${project.projectDir}/../../..")
+
+                def generated = new File("${compileTask.abi.getCxxBuildFolder()}/compile_commands.json")
+                def output = new File("${monorepoDir}/compile_commands.json")
+
+                output.text = generated.text
+
+                println("Generated clangd metadata.")
+            }
+    }
+}
+
+def assertMinimalReactNativeVersion = task assertMinimalReactNativeVersionTask {
+    // If you change the minimal React Native version remember to update Compatibility Table in docs
+    def minimalReactNativeVersion = 78
+    onlyIf { REACT_NATIVE_MINOR_VERSION < minimalReactNativeVersion }
+    doFirst {
+        throw new GradleException("[Reanimated] Unsupported React Native version. Please use $minimalReactNativeVersion. or newer.")
+    }
+}
+
+task prepareWorkletsHeadersForPrefabs(type: Copy) {
+    from("$projectDir/src/main/cpp")
+    from("$projectDir/../Common/cpp")
+    include("worklets/**/*.h")
+    into(workletsPrefabHeadersDir)
+}
+
+task prepareReanimatedHeadersForPrefabs(type: Copy) {
+    from("$projectDir/src/main/cpp")
+    from("$projectDir/../Common/cpp")
+    include("reanimated/**/*.h")
+    into(reanimatedPrefabHeadersDir)
+}
+
+tasks.preBuild {
+    dependsOn assertMinimalReactNativeVersion
+}
+
+task cleanCmakeCache() {
+    tasks.getByName("clean").dependsOn(cleanCmakeCache)
+    doFirst {
+        delete "${projectDir}/.cxx"
+    }
+}
+
+task printVersions {
+    println "Android gradle plugin: ${Version.ANDROID_GRADLE_PLUGIN_VERSION}"
+    println "Gradle: ${project.gradle.gradleVersion}"
+}
+
+task createNativeDepsDirectories() {
+    downloadsDir.mkdirs()
+    thirdPartyNdkDir.mkdirs()
+    workletsPrefabHeadersDir.mkdirs()
+    reanimatedPrefabHeadersDir.mkdirs()
+}
+
+task packageNdkLibs(type: Copy) {
+    from("$buildDir/reanimated-ndk/all")
+    include("**/libworklets.so")
+    include("**/libreanimated.so")
+    into("$projectDir/src/main/jniLibs")
+}
+
+repositories {
+    mavenCentral()
+    mavenLocal()
+    maven {
+        // All of React Native (JS, Obj-C sources, Android binaries) is installed from npm
+        url "$reactNativeRootDir/android"
+    }
+    maven {
+        // Android JSC is installed from npm
+        url "$reactNativeRootDir/../jsc-android/dist"
+    }
+    google()
+}
+
+dependencies {
+    implementation "com.facebook.yoga:proguard-annotations:1.19.0"
+    implementation "androidx.transition:transition:1.1.0"
+    implementation "androidx.core:core:1.6.0"
+
+    implementation "com.facebook.react:react-android" // version substituted by RNGP
+    if (JS_RUNTIME == "hermes") {
+        implementation "com.facebook.react:hermes-android" // version substituted by RNGP
+    }
+}
+
+def nativeBuildDependsOn(dependsOnTask) {
+    def buildTasks = tasks.findAll({ task -> (
+        !task.name.contains("Clean")
+        && (task.name.contains("externalNative")
+            || task.name.contains("CMake")
+            || task.name.contains("generateJsonModel")
+        )
+    ) })
+    buildTasks.forEach { task -> task.dependsOn(dependsOnTask) }
+}
+
+afterEvaluate {
+    preBuild.dependsOn(prepareWorkletsHeadersForPrefabs)
+    preBuild.dependsOn(prepareReanimatedHeadersForPrefabs)
+
+    tasks.forEach({ task ->
+        if (task.name.contains("JniLibFolders")) {
+            task.dependsOn(packageNdkLibs)
+        }
+    })
+
+    if (JS_RUNTIME == "hermes") {
+        // Do nothing
+    } else if (JS_RUNTIME == "v8") {
+        def buildTasks = tasks.findAll({ task ->
+            !task.name.contains("Clean") && (task.name.contains("externalNative") || task.name.contains("CMake") || task.name.startsWith("generateJsonModel")) })
+        buildTasks.forEach { task ->
+            def buildType = task.name.endsWith('Debug') ? 'Debug' : 'Release'
+            task.dependsOn(":react-native-v8:copy${buildType}JniLibsProjectOnly")
+        }
+    } else if (JS_RUNTIME == "jsc") {
+        // Do nothing
+    } else {
+      throw GradleScriptException("[Reanimated] Unknown JS runtime ${JS_RUNTIME}.")
+    }
+}
diff --git a/node_modules/react-native-reanimated/android/src/main/cpp/reanimated/CMakeLists.txt b/node_modules/react-native-reanimated/android/src/main/cpp/reanimated/CMakeLists.txt
index c61b03a..b5a6ba8 100644
--- a/node_modules/react-native-reanimated/android/src/main/cpp/reanimated/CMakeLists.txt
+++ b/node_modules/react-native-reanimated/android/src/main/cpp/reanimated/CMakeLists.txt
@@ -36,3 +36,55 @@ if(ReactAndroid_VERSION_MINOR GREATER_EQUAL 76)
 else()
   target_link_libraries(reanimated ReactAndroid::react_nativemodule_core)
 endif()
+
+# React Native 0.82+: worklets links hermesvm, but we need to ensure the library path
+# is available for reanimated as well. Add the same hermesvm library directories.
+if(${JS_RUNTIME} STREQUAL "hermes")
+  # Try to find hermesvm library directories from Gradle cache
+  set(GRADLE_CACHE_BASES
+    "$ENV{HOME}/.gradle/caches"
+    "/root/.gradle/caches"
+    "/home/runner/.gradle/caches")
+  
+  set(HERMES_LIB_DIR_FOUND FALSE)
+  foreach(GRADLE_CACHE_BASE ${GRADLE_CACHE_BASES})
+    if(EXISTS "${GRADLE_CACHE_BASE}")
+      # Try pattern: */transformed/hermes-android-*/prefab/modules/hermesvm/libs/android.*/libhermesvm.so
+      file(GLOB HERMES_LIBS "${GRADLE_CACHE_BASE}/*/transforms/*/transformed/hermes-android-*/prefab/modules/hermesvm/libs/android.*/libhermesvm.so")
+      if(HERMES_LIBS)
+        # Find the one matching current ABI
+        foreach(HERMES_LIB ${HERMES_LIBS})
+          if(HERMES_LIB MATCHES "android\\.${ANDROID_ABI}/libhermesvm\\.so")
+            get_filename_component(HERMES_LIB_DIR "${HERMES_LIB}" DIRECTORY)
+            target_link_directories(reanimated PRIVATE "${HERMES_LIB_DIR}")
+            message(STATUS "reanimated: Added hermesvm library directory: ${HERMES_LIB_DIR} (ABI: ${ANDROID_ABI})")
+            set(HERMES_LIB_DIR_FOUND TRUE)
+            break()
+          endif()
+        endforeach()
+        # If no ABI match found, use the first one
+        if(NOT HERMES_LIB_DIR_FOUND)
+          list(GET HERMES_LIBS 0 HERMES_LIB)
+          get_filename_component(HERMES_LIB_DIR "${HERMES_LIB}" DIRECTORY)
+          target_link_directories(reanimated PRIVATE "${HERMES_LIB_DIR}")
+          message(STATUS "reanimated: Added hermesvm library directory: ${HERMES_LIB_DIR} (fallback)")
+          set(HERMES_LIB_DIR_FOUND TRUE)
+        endif()
+        break()
+      endif()
+      
+      # Fallback: try old pattern
+      if(NOT HERMES_LIB_DIR_FOUND)
+        file(GLOB HERMES_LIBS "${GRADLE_CACHE_BASE}/*/transforms/*/transformed/hermes-android-*/prefab/modules/hermesvm/lib/*/libhermesvm.so")
+        if(HERMES_LIBS)
+          list(GET HERMES_LIBS 0 HERMES_LIB)
+          get_filename_component(HERMES_LIB_DIR "${HERMES_LIB}" DIRECTORY)
+          target_link_directories(reanimated PRIVATE "${HERMES_LIB_DIR}")
+          message(STATUS "reanimated: Added hermesvm library directory: ${HERMES_LIB_DIR} (legacy)")
+          set(HERMES_LIB_DIR_FOUND TRUE)
+          break()
+        endif()
+      endif()
+    endif()
+  endforeach()
+endif()
diff --git a/node_modules/react-native-reanimated/android/src/main/cpp/worklets/CMakeLists.txt b/node_modules/react-native-reanimated/android/src/main/cpp/worklets/CMakeLists.txt
index bb61ff7..4192bc7 100644
--- a/node_modules/react-native-reanimated/android/src/main/cpp/worklets/CMakeLists.txt
+++ b/node_modules/react-native-reanimated/android/src/main/cpp/worklets/CMakeLists.txt
@@ -10,7 +10,29 @@ find_package(fbjni REQUIRED CONFIG)
 find_package(ReactAndroid REQUIRED CONFIG)
 
 if(${JS_RUNTIME} STREQUAL "hermes")
-  find_package(hermes-engine REQUIRED CONFIG)
+  # React Native 0.82+ uses ReactAndroid prefab for Hermes
+  # Try to find hermes-engine prefab first, fallback to ReactAndroid::hermes if not found
+  find_package(hermes-engine CONFIG QUIET)
+  if(NOT hermes-engine_FOUND)
+    # React Native 0.82+ provides Hermes through ReactAndroid prefab
+    # In RN 0.82+, Hermes is included in ReactAndroid::reactnative, so we don't need to link it separately
+    # But we still need to add Hermes header include paths
+    message(STATUS "hermes-engine prefab not found, adding Hermes header paths manually")
+    # Add Hermes header include paths for React Native 0.82+
+    # Hermes headers are in sdks/hermes/include (hermes/hermes.h)
+    if(EXISTS "${JS_RUNTIME_DIR}/include")
+      target_include_directories(worklets PRIVATE "${JS_RUNTIME_DIR}/include")
+      message(STATUS "Added Hermes include path: ${JS_RUNTIME_DIR}/include")
+    endif()
+    # Also check ReactCommon/hermes for additional headers
+    if(EXISTS "${REACT_NATIVE_DIR}/ReactCommon/hermes")
+      target_include_directories(worklets PRIVATE "${REACT_NATIVE_DIR}/ReactCommon/hermes")
+      message(STATUS "Added ReactCommon/hermes include path")
+    endif()
+  else()
+    # hermes-engine prefab found, it should provide headers automatically
+    message(STATUS "hermes-engine prefab found, using prefab headers")
+  endif()
 endif()
 
 add_library(worklets SHARED ${WORKLETS_COMMON_CPP_SOURCES}
@@ -28,6 +50,92 @@ target_include_directories(
           "${REACT_NATIVE_DIR}/ReactCommon/callinvoker"
           "${REACT_NATIVE_DIR}/ReactCommon/runtimeexecutor")
 
+# Add Hermes headers if using Hermes runtime
+# React Native 0.82+ includes Hermes headers through hermes-android AAR prefab
+if(${JS_RUNTIME} STREQUAL "hermes")
+  # Try to get headers from hermes-engine prefab first
+  if(TARGET hermes-engine::libhermes)
+    # Prefab found, headers should be available through INTERFACE_INCLUDE_DIRECTORIES
+    message(STATUS "hermes-engine::libhermes target found, using prefab headers")
+  elseif(DEFINED HERMES_INCLUDE_DIRS_LIST)
+    # Add manually found Hermes include directories
+    foreach(HERMES_DIR ${HERMES_INCLUDE_DIRS_LIST})
+      target_include_directories(worklets PRIVATE "${HERMES_DIR}")
+      message(STATUS "Added Hermes include: ${HERMES_DIR}")
+    endforeach()
+  else()
+    # Last resort: try common Hermes header locations
+    message(STATUS "Searching for Hermes headers in common locations")
+    
+    # React Native 0.82: hermes-android AAR provides prefab with headers
+    # Prefab is usually in CMAKE_FIND_ROOT_PATH/prefab/modules/hermes-engine
+    # But we need to find the actual header location
+    # Try multiple possible locations
+    
+    # 1. JS_RUNTIME_DIR/include (Hermes SDK standard location)
+    if(EXISTS "${JS_RUNTIME_DIR}/include")
+      target_include_directories(worklets PRIVATE "${JS_RUNTIME_DIR}/include")
+      message(STATUS "Added Hermes include: ${JS_RUNTIME_DIR}/include")
+    else()
+      message(WARNING "Hermes include directory not found at ${JS_RUNTIME_DIR}/include")
+    endif()
+    
+    # 2. Try to find hermes-android prefab
+    # React Native 0.82: hermes-android AAR provides prefab with module name "hermesvm"
+    # Headers are at: prefab/modules/hermesvm/include/hermes/hermes.h
+    # Try CMAKE_FIND_ROOT_PATH first
+    set(HERMES_INCLUDE_FOUND FALSE)
+    foreach(ROOT_PATH ${CMAKE_FIND_ROOT_PATH})
+      # Try hermesvm module (actual module name in hermes-android AAR)
+      set(PREFAB_HERMESVM_DIR "${ROOT_PATH}/prefab/modules/hermesvm")
+      if(EXISTS "${PREFAB_HERMESVM_DIR}/include")
+        target_include_directories(worklets PRIVATE "${PREFAB_HERMESVM_DIR}/include")
+        message(STATUS "Added Hermes include from hermesvm prefab: ${PREFAB_HERMESVM_DIR}/include")
+        set(HERMES_INCLUDE_FOUND TRUE)
+        break()
+      endif()
+      # Also try hermes-engine (legacy name, might exist in some versions)
+      set(PREFAB_HERMES_DIR "${ROOT_PATH}/prefab/modules/hermes-engine")
+      if(EXISTS "${PREFAB_HERMES_DIR}/include")
+        target_include_directories(worklets PRIVATE "${PREFAB_HERMES_DIR}/include")
+        message(STATUS "Added Hermes include from hermes-engine prefab: ${PREFAB_HERMES_DIR}/include")
+        set(HERMES_INCLUDE_FOUND TRUE)
+        break()
+      endif()
+    endforeach()
+    
+    # 3. If not found in CMAKE_FIND_ROOT_PATH, try Gradle cache
+    if(NOT HERMES_INCLUDE_FOUND)
+      # hermes-android AAR is at: .../transformed/hermes-android-*/prefab/modules/hermesvm/include
+      set(GRADLE_CACHE_PATTERNS
+        "$ENV{HOME}/.gradle/caches/*/transforms/*/transformed/hermes-android-*/prefab/modules/hermesvm/include"
+        "/root/.gradle/caches/*/transforms/*/transformed/hermes-android-*/prefab/modules/hermesvm/include"
+        "/home/runner/.gradle/caches/*/transforms/*/transformed/hermes-android-*/prefab/modules/hermesvm/include"
+        # Also try hermes-engine (legacy)
+        "$ENV{HOME}/.gradle/caches/*/transforms/*/transformed/hermes-android-*/prefab/modules/hermes-engine/include"
+        "/root/.gradle/caches/*/transforms/*/transformed/hermes-android-*/prefab/modules/hermes-engine/include"
+        "/home/runner/.gradle/caches/*/transforms/*/transformed/hermes-android-*/prefab/modules/hermes-engine/include"
+      )
+      foreach(PATTERN ${GRADLE_CACHE_PATTERNS})
+        file(GLOB HERMES_TRANSFORMS ${PATTERN})
+        if(HERMES_TRANSFORMS)
+          list(GET HERMES_TRANSFORMS 0 HERMES_INCLUDE)
+          target_include_directories(worklets PRIVATE "${HERMES_INCLUDE}")
+          message(STATUS "Added Hermes include from Gradle cache: ${HERMES_INCLUDE}")
+          set(HERMES_INCLUDE_FOUND TRUE)
+          break()
+        endif()
+      endforeach()
+    endif()
+    
+    # 3. Try ReactCommon/hermes (might have some headers, but not hermes/hermes.h)
+    if(EXISTS "${REACT_NATIVE_DIR}/ReactCommon/hermes")
+      target_include_directories(worklets PRIVATE "${REACT_NATIVE_DIR}/ReactCommon/hermes")
+      message(STATUS "Added ReactCommon/hermes include")
+    endif()
+  endif()
+endif()
+
 if(${IS_NEW_ARCHITECTURE_ENABLED})
   target_include_directories(
     worklets
@@ -57,14 +165,143 @@ else()
 endif()
 
 if(${JS_RUNTIME} STREQUAL "hermes")
-  target_link_libraries(worklets hermes-engine::libhermes)
+  # React Native 0.82+: hermes-android AAR provides hermesvm prefab
+  # Try to find and link Hermes library
+  set(HERMES_LINKED FALSE)
+  
+  # First, try to locate hermes-android AAR prefab directory and add it to CMAKE_PREFIX_PATH
+  # This allows find_package(hermesvm) to work correctly
+  set(GRADLE_CACHE_BASES
+    "$ENV{HOME}/.gradle/caches"
+    "/root/.gradle/caches"
+    "/home/runner/.gradle/caches")
+  
+  foreach(GRADLE_CACHE_BASE ${GRADLE_CACHE_BASES})
+    if(EXISTS "${GRADLE_CACHE_BASE}")
+      file(GLOB HERMES_PREFAB_DIRS "${GRADLE_CACHE_BASE}/*/transforms/*/transformed/hermes-android-*/prefab")
+      if(HERMES_PREFAB_DIRS)
+        list(GET HERMES_PREFAB_DIRS 0 HERMES_PREFAB_ROOT)
+        # Set CMAKE_PREFIX_PATH to include hermes-android prefab directory
+        # Use set() instead of list(APPEND) to ensure it works even if CMAKE_PREFIX_PATH is cached
+        if(CMAKE_PREFIX_PATH)
+          set(CMAKE_PREFIX_PATH "${CMAKE_PREFIX_PATH};${HERMES_PREFAB_ROOT}")
+        else()
+          set(CMAKE_PREFIX_PATH "${HERMES_PREFAB_ROOT}")
+        endif()
+        message(STATUS "Added hermes-android prefab to CMAKE_PREFIX_PATH: ${HERMES_PREFAB_ROOT}")
+        break()
+      endif()
+    endif()
+  endforeach()
+  
+  # React Native 0.82+: ReactAndroid::reactnative includes Hermes, but we need explicit linking
+  # First try ReactAndroid::hermesvm (React Native 0.82+)
+  if(NOT HERMES_LINKED AND TARGET ReactAndroid::hermesvm)
+    target_link_libraries(worklets ReactAndroid::hermesvm)
+    message(STATUS "Linking ReactAndroid::hermesvm")
+    set(HERMES_LINKED TRUE)
+  endif()
+  
+  # Try hermesvm prefab (React Native 0.82+) - now with updated CMAKE_PREFIX_PATH
+  if(NOT HERMES_LINKED)
+    find_package(hermesvm CONFIG QUIET)
+    if(hermesvm_FOUND AND TARGET hermesvm::hermesvm)
+      target_link_libraries(worklets hermesvm::hermesvm)
+      message(STATUS "Linking hermesvm::hermesvm")
+      set(HERMES_LINKED TRUE)
+    endif()
+  endif()
+  
+  # Try hermes-engine prefab (legacy)
+  if(NOT HERMES_LINKED)
+    find_package(hermes-engine CONFIG QUIET)
+    if(hermes-engine_FOUND AND TARGET hermes-engine::libhermes)
+      target_link_libraries(worklets hermes-engine::libhermes)
+      message(STATUS "Linking hermes-engine::libhermes")
+      set(HERMES_LINKED TRUE)
+    endif()
+  endif()
+  
+  # Try ReactAndroid::hermes (older React Native versions)
+  if(NOT HERMES_LINKED AND TARGET ReactAndroid::hermes)
+    target_link_libraries(worklets ReactAndroid::hermes)
+    message(STATUS "Linking ReactAndroid::hermes")
+    set(HERMES_LINKED TRUE)
+  endif()
+  
+  # React Native 0.82+: Hermes might be included in ReactAndroid::reactnative
+  # But react-native-reanimated needs explicit Hermes symbols for createHermesRuntime
+  # Try to find and link hermes-android AAR library directly from Gradle cache
+  if(NOT HERMES_LINKED)
+    # React Native 0.82.1: hermes-android AAR structure is:
+    # .../transformed/hermes-android-0.82.1-release/prefab/modules/hermesvm/libs/android.${ANDROID_ABI}/libhermesvm.so
+    set(GRADLE_CACHE_BASES
+      "$ENV{HOME}/.gradle/caches"
+      "/root/.gradle/caches"
+      "/home/runner/.gradle/caches")
+    
+    # Try to find libhermesvm.so with ABI-specific path
+    foreach(GRADLE_CACHE_BASE ${GRADLE_CACHE_BASES})
+      if(EXISTS "${GRADLE_CACHE_BASE}")
+        # Try pattern: */transformed/hermes-android-*/prefab/modules/hermesvm/libs/android.*/libhermesvm.so
+        file(GLOB HERMES_LIBS "${GRADLE_CACHE_BASE}/*/transforms/*/transformed/hermes-android-*/prefab/modules/hermesvm/libs/android.*/libhermesvm.so")
+        if(HERMES_LIBS)
+          # Find the one matching current ABI
+          foreach(HERMES_LIB ${HERMES_LIBS})
+            if(HERMES_LIB MATCHES "android\\.${ANDROID_ABI}/libhermesvm\\.so")
+              get_filename_component(HERMES_LIB_DIR "${HERMES_LIB}" DIRECTORY)
+              target_link_directories(worklets PRIVATE "${HERMES_LIB_DIR}")
+              target_link_libraries(worklets hermesvm)
+              message(STATUS "Linking hermesvm library from: ${HERMES_LIB_DIR} (ABI: ${ANDROID_ABI})")
+              set(HERMES_LINKED TRUE)
+              break()
+            endif()
+          endforeach()
+          # If no ABI match found, use the first one (better than nothing)
+          if(NOT HERMES_LINKED)
+            list(GET HERMES_LIBS 0 HERMES_LIB)
+            get_filename_component(HERMES_LIB_DIR "${HERMES_LIB}" DIRECTORY)
+            target_link_directories(worklets PRIVATE "${HERMES_LIB_DIR}")
+            target_link_libraries(worklets hermesvm)
+            message(STATUS "Linking hermesvm library from: ${HERMES_LIB_DIR} (fallback, no ABI match)")
+            set(HERMES_LINKED TRUE)
+          endif()
+          break()
+        endif()
+        
+        # Fallback: try old pattern without ABI-specific path
+        if(NOT HERMES_LINKED)
+          file(GLOB HERMES_LIBS "${GRADLE_CACHE_BASE}/*/transforms/*/transformed/hermes-android-*/prefab/modules/hermesvm/lib/*/libhermesvm.so")
+          if(HERMES_LIBS)
+            list(GET HERMES_LIBS 0 HERMES_LIB)
+            get_filename_component(HERMES_LIB_DIR "${HERMES_LIB}" DIRECTORY)
+            target_link_directories(worklets PRIVATE "${HERMES_LIB_DIR}")
+            target_link_libraries(worklets hermesvm)
+            message(STATUS "Linking hermesvm library from: ${HERMES_LIB_DIR} (legacy pattern)")
+            set(HERMES_LINKED TRUE)
+            break()
+          endif()
+        endif()
+      endif()
+    endforeach()
+  endif()
+  
+  # Last resort: Try to use ReactAndroid::reactnative which includes Hermes in RN 0.82+
+  # But we still need explicit Hermes symbols, so this will likely fail
+  if(NOT HERMES_LINKED)
+    message(FATAL_ERROR "Hermes library (hermesvm) not found. ReactAndroid::reactnative includes Hermes but react-native-reanimated needs explicit Hermes symbols (makeHermesRuntime). Please ensure hermes-android AAR is properly included in the build.")
+  endif()
 
   if(${HERMES_ENABLE_DEBUGGER})
     string(APPEND CMAKE_CXX_FLAGS " -DHERMES_ENABLE_DEBUGGER=1")
     if(ReactAndroid_VERSION_MINOR GREATER_EQUAL 76)
-      target_link_libraries(worklets ReactAndroid::hermestooling)
+      if(TARGET ReactAndroid::hermestooling)
+        target_link_libraries(worklets ReactAndroid::hermestooling)
+      endif()
     else()
-      target_link_libraries(worklets ReactAndroid::hermes_executor)
+      if(TARGET ReactAndroid::hermes_executor)
+        target_link_libraries(worklets ReactAndroid::hermes_executor)
+      endif()
     endif()
   endif()
 elseif(${JS_RUNTIME} STREQUAL "jsc")
diff --git a/node_modules/react-native-reanimated/android/src/main/java/com/swmansion/reanimated/ReanimatedModule.java b/node_modules/react-native-reanimated/android/src/main/java/com/swmansion/reanimated/ReanimatedModule.java
index 14d252c..79a0977 100644
--- a/node_modules/react-native-reanimated/android/src/main/java/com/swmansion/reanimated/ReanimatedModule.java
+++ b/node_modules/react-native-reanimated/android/src/main/java/com/swmansion/reanimated/ReanimatedModule.java
@@ -10,7 +10,6 @@ import com.facebook.react.bridge.UIManagerListener;
 import com.facebook.react.fabric.FabricUIManager;
 import com.facebook.react.module.annotations.ReactModule;
 import com.facebook.react.uimanager.UIManagerModule;
-import com.facebook.react.uimanager.UIManagerModuleListener;
 import com.swmansion.worklets.WorkletsModule;
 import java.util.ArrayList;
 import java.util.Objects;
diff --git a/node_modules/react-native-reanimated/android/src/main/java/com/swmansion/reanimated/UIManagerModuleListener.java b/node_modules/react-native-reanimated/android/src/main/java/com/swmansion/reanimated/UIManagerModuleListener.java
new file mode 100644
index 0000000..4163fea
--- /dev/null
+++ b/node_modules/react-native-reanimated/android/src/main/java/com/swmansion/reanimated/UIManagerModuleListener.java
@@ -0,0 +1,10 @@
+package com.swmansion.reanimated;
+
+import com.facebook.react.uimanager.UIManagerModule;
+
+// UIManagerModuleListener is removed in React Native 0.82+ (New Architecture only)
+// Create a dummy interface for compatibility with react-native-reanimated 3.19.3
+public interface UIManagerModuleListener {
+  void willDispatchViewUpdates(UIManagerModule uiManager);
+}
+
