package com.mindgarden.consultation.service.impl;

import java.math.BigDecimal;
import java.math.RoundingMode;
import java.time.LocalDate;
import java.util.ArrayList;
import java.util.HashMap;
import java.util.List;
import java.util.Map;
import java.util.stream.Collectors;
import com.mindgarden.consultation.constant.UserRole;
import com.mindgarden.consultation.dto.FinancialDashboardResponse;
import com.mindgarden.consultation.dto.FinancialTransactionRequest;
import com.mindgarden.consultation.dto.FinancialTransactionResponse;
import com.mindgarden.consultation.entity.FinancialTransaction;
import com.mindgarden.consultation.entity.Payment;
import com.mindgarden.consultation.entity.PurchaseRequest;
import com.mindgarden.consultation.entity.SalaryCalculation;
import com.mindgarden.consultation.entity.User;
import com.mindgarden.consultation.repository.FinancialTransactionRepository;
import com.mindgarden.consultation.repository.PaymentRepository;
import com.mindgarden.consultation.repository.PurchaseRequestRepository;
import com.mindgarden.consultation.repository.SalaryCalculationRepository;
import com.mindgarden.consultation.service.CommonCodeService;
import com.mindgarden.consultation.service.FinancialTransactionService;
import org.springframework.data.domain.Page;
import org.springframework.data.domain.Pageable;
import org.springframework.stereotype.Service;
import org.springframework.transaction.annotation.Transactional;
import lombok.RequiredArgsConstructor;
import lombok.extern.slf4j.Slf4j;

/**
 * ÌöåÍ≥Ñ Í±∞Îûò ÏÑúÎπÑÏä§ Íµ¨ÌòÑÏ≤¥
 * 
 * @author MindGarden
 * @version 1.0.0
 * @since 2025-01-11
 */
@Slf4j
@Service
@RequiredArgsConstructor
@Transactional
public class FinancialTransactionServiceImpl implements FinancialTransactionService {
    
    private final FinancialTransactionRepository financialTransactionRepository;
    private final SalaryCalculationRepository salaryCalculationRepository;
    private final PurchaseRequestRepository purchaseRequestRepository;
    private final PaymentRepository paymentRepository;
    private final CommonCodeService commonCodeService;
    
    @Override
    public FinancialTransactionResponse createTransaction(FinancialTransactionRequest request, User currentUser) {
        log.info("üíº ÌöåÍ≥Ñ Í±∞Îûò ÏÉùÏÑ±: Ïú†Ìòï={}, Í∏àÏï°={}, Ïπ¥ÌÖåÍ≥†Î¶¨={}", 
                request.getTransactionType(), request.getAmount(), request.getCategory());
        
        // Í∂åÌïú ÌôïÏù∏ (ÏãúÏä§ÌÖú ÏûêÎèô Ï≤òÎ¶¨Í∞Ä ÏïÑÎãå Í≤ΩÏö∞ÏóêÎßå)
        if (currentUser != null) {
            if (!UserRole.HQ_MASTER.equals(currentUser.getRole()) && 
                !UserRole.ADMIN.equals(currentUser.getRole()) && 
                !UserRole.BRANCH_SUPER_ADMIN.equals(currentUser.getRole())) {
                throw new RuntimeException("ÌöåÍ≥Ñ Í±∞Îûò ÏÉùÏÑ± Í∂åÌïúÏù¥ ÏóÜÏäµÎãàÎã§.");
            }
            log.info("üíº ÏÇ¨Ïö©Ïûê Í∂åÌïú ÌôïÏù∏ ÏôÑÎ£å: {}", currentUser.getRole());
        } else {
            log.info("üíº ÏãúÏä§ÌÖú ÏûêÎèô Í±∞Îûò ÏÉùÏÑ± (Í∂åÌïú Í≤ÄÏÇ¨ Ïö∞Ìöå)");
        }
        
        FinancialTransaction transaction = FinancialTransaction.builder()
                .transactionType(FinancialTransaction.TransactionType.valueOf(request.getTransactionType()))
                .category(request.getCategory())
                .subcategory(request.getSubcategory())
                .amount(request.getAmount())
                .description(request.getDescription())
                .transactionDate(request.getTransactionDate())
                .relatedEntityId(request.getRelatedEntityId())
                .relatedEntityType(request.getRelatedEntityType())
                .department(request.getDepartment())
                .projectCode(request.getProjectCode())
                .branchCode(request.getBranchCode())
                .taxIncluded(request.getTaxIncluded() != null ? request.getTaxIncluded() : false)
                .taxAmount(request.getTaxAmount() != null ? request.getTaxAmount() : BigDecimal.ZERO)
                .amountBeforeTax(request.getAmountBeforeTax() != null ? request.getAmountBeforeTax() : request.getAmount())
                .remarks(request.getRemarks())
                .status(FinancialTransaction.TransactionStatus.PENDING)
                .build();
        
        FinancialTransaction savedTransaction = financialTransactionRepository.save(transaction);
        
        log.info("‚úÖ ÌöåÍ≥Ñ Í±∞Îûò ÏÉùÏÑ± ÏôÑÎ£å: ID={}", savedTransaction.getId());
        return convertToResponse(savedTransaction);
    }
    
    @Override
    public FinancialTransactionResponse updateTransaction(Long id, FinancialTransactionRequest request, User currentUser) {
        log.info("üíº ÌöåÍ≥Ñ Í±∞Îûò ÏàòÏ†ï: ID={}", id);
        
        // Í∂åÌïú ÌôïÏù∏
        if (!UserRole.HQ_MASTER.equals(currentUser.getRole()) && 
            !UserRole.ADMIN.equals(currentUser.getRole()) && 
            !UserRole.BRANCH_SUPER_ADMIN.equals(currentUser.getRole())) {
            throw new RuntimeException("ÌöåÍ≥Ñ Í±∞Îûò ÏàòÏ†ï Í∂åÌïúÏù¥ ÏóÜÏäµÎãàÎã§.");
        }
        
        FinancialTransaction transaction = financialTransactionRepository.findById(id)
                .orElseThrow(() -> new RuntimeException("Í±∞ÎûòÎ•º Ï∞æÏùÑ Ïàò ÏóÜÏäµÎãàÎã§: " + id));
        
        // ÏäπÏù∏Îêú Í±∞ÎûòÎäî ÏàòÏ†ï Î∂àÍ∞Ä
        if (transaction.isApproved()) {
            throw new RuntimeException("ÏäπÏù∏Îêú Í±∞ÎûòÎäî ÏàòÏ†ïÌï† Ïàò ÏóÜÏäµÎãàÎã§.");
        }
        
        // Í±∞Îûò Ï†ïÎ≥¥ ÏóÖÎç∞Ïù¥Ìä∏
        transaction.setTransactionType(FinancialTransaction.TransactionType.valueOf(request.getTransactionType()));
        transaction.setCategory(request.getCategory());
        transaction.setSubcategory(request.getSubcategory());
        transaction.setAmount(request.getAmount());
        transaction.setDescription(request.getDescription());
        transaction.setTransactionDate(request.getTransactionDate());
        transaction.setRelatedEntityId(request.getRelatedEntityId());
        transaction.setRelatedEntityType(request.getRelatedEntityType());
        transaction.setDepartment(request.getDepartment());
        transaction.setProjectCode(request.getProjectCode());
        transaction.setBranchCode(request.getBranchCode());
        transaction.setTaxIncluded(request.getTaxIncluded() != null ? request.getTaxIncluded() : false);
        transaction.setTaxAmount(request.getTaxAmount() != null ? request.getTaxAmount() : BigDecimal.ZERO);
        transaction.setAmountBeforeTax(request.getAmountBeforeTax() != null ? request.getAmountBeforeTax() : request.getAmount());
        transaction.setRemarks(request.getRemarks());
        
        FinancialTransaction savedTransaction = financialTransactionRepository.save(transaction);
        
        log.info("‚úÖ ÌöåÍ≥Ñ Í±∞Îûò ÏàòÏ†ï ÏôÑÎ£å: ID={}", savedTransaction.getId());
        return convertToResponse(savedTransaction);
    }
    
    @Override
    public void deleteTransaction(Long id, User currentUser) {
        log.info("üíº ÌöåÍ≥Ñ Í±∞Îûò ÏÇ≠Ï†ú: ID={}", id);
        
        // ÏàòÌçºÏñ¥ÎìúÎØºÎßå ÏÇ≠Ï†ú Í∞ÄÎä•
        if (!UserRole.HQ_MASTER.equals(currentUser.getRole())) {
            throw new RuntimeException("ÌöåÍ≥Ñ Í±∞Îûò ÏÇ≠Ï†ú Í∂åÌïúÏù¥ ÏóÜÏäµÎãàÎã§.");
        }
        
        FinancialTransaction transaction = financialTransactionRepository.findById(id)
                .orElseThrow(() -> new RuntimeException("Í±∞ÎûòÎ•º Ï∞æÏùÑ Ïàò ÏóÜÏäµÎãàÎã§: " + id));
        
        // ÏäπÏù∏Îêú Í±∞ÎûòÎäî ÏÇ≠Ï†ú Î∂àÍ∞Ä (ÎÖºÎ¶¨ ÏÇ≠Ï†ú)
        transaction.setIsDeleted(true);
        financialTransactionRepository.save(transaction);
        
        log.info("‚úÖ ÌöåÍ≥Ñ Í±∞Îûò ÏÇ≠Ï†ú ÏôÑÎ£å: ID={}", id);
    }
    
    @Override
    @Transactional(readOnly = true)
    public FinancialTransactionResponse getTransaction(Long id) {
        FinancialTransaction transaction = financialTransactionRepository.findById(id)
                .orElseThrow(() -> new RuntimeException("Í±∞ÎûòÎ•º Ï∞æÏùÑ Ïàò ÏóÜÏäµÎãàÎã§: " + id));
        
        return convertToResponse(transaction);
    }
    
    @Override
    @Transactional(readOnly = true)
    public Page<FinancialTransactionResponse> getTransactions(Pageable pageable) {
        Page<FinancialTransaction> transactions = financialTransactionRepository
                .findByIsDeletedFalseOrderByTransactionDateDescCreatedAtDesc(pageable);
        
        return transactions.map(this::convertToResponse);
    }
    
    @Override
    @Transactional(readOnly = true)
    public Page<FinancialTransactionResponse> getTransactionsByType(FinancialTransaction.TransactionType type, Pageable pageable) {
        Page<FinancialTransaction> transactions = financialTransactionRepository
                .findByTransactionTypeAndIsDeletedFalseOrderByTransactionDateDescCreatedAtDesc(type, pageable);
        
        return transactions.map(this::convertToResponse);
    }
    
    @Override
    @Transactional(readOnly = true)
    public Page<FinancialTransactionResponse> getTransactionsByCategory(String category, Pageable pageable) {
        Page<FinancialTransaction> transactions = financialTransactionRepository
                .findByCategoryAndIsDeletedFalseOrderByTransactionDateDescCreatedAtDesc(category, pageable);
        
        return transactions.map(this::convertToResponse);
    }
    
    @Override
    @Transactional(readOnly = true)
    public Page<FinancialTransactionResponse> getTransactionsByDateRange(LocalDate startDate, LocalDate endDate, Pageable pageable) {
        Page<FinancialTransaction> transactions = financialTransactionRepository
                .findByTransactionDateBetweenAndIsDeletedFalseOrderByTransactionDateDescCreatedAtDesc(startDate, endDate, pageable);
        
        return transactions.map(this::convertToResponse);
    }
    
    @Override
    @Transactional(readOnly = true)
    public List<FinancialTransactionResponse> getPendingTransactions() {
        List<FinancialTransaction> transactions = financialTransactionRepository
                .findByStatusAndIsDeletedFalseOrderByCreatedAtDesc(FinancialTransaction.TransactionStatus.PENDING);
        
        return transactions.stream()
                .map(this::convertToResponse)
                .collect(Collectors.toList());
    }
    
    @Override
    public FinancialTransactionResponse approveTransaction(Long id, String comment, User approver) {
        log.info("‚úÖ ÌöåÍ≥Ñ Í±∞Îûò ÏäπÏù∏: ID={}, ÏäπÏù∏Ïûê={}", id, approver.getEmail());
        
        // ÏàòÌçºÏñ¥ÎìúÎØºÎßå ÏäπÏù∏ Í∞ÄÎä•
        if (!UserRole.HQ_MASTER.equals(approver.getRole())) {
            throw new RuntimeException("Í±∞Îûò ÏäπÏù∏ Í∂åÌïúÏù¥ ÏóÜÏäµÎãàÎã§.");
        }
        
        FinancialTransaction transaction = financialTransactionRepository.findById(id)
                .orElseThrow(() -> new RuntimeException("Í±∞ÎûòÎ•º Ï∞æÏùÑ Ïàò ÏóÜÏäµÎãàÎã§: " + id));
        
        if (!transaction.isApprovable()) {
            throw new RuntimeException("ÏäπÏù∏ Í∞ÄÎä•Ìïú ÏÉÅÌÉúÍ∞Ä ÏïÑÎãôÎãàÎã§.");
        }
        
        transaction.approve(approver, comment);
        FinancialTransaction savedTransaction = financialTransactionRepository.save(transaction);
        
        log.info("‚úÖ ÌöåÍ≥Ñ Í±∞Îûò ÏäπÏù∏ ÏôÑÎ£å: ID={}", savedTransaction.getId());
        return convertToResponse(savedTransaction);
    }
    
    @Override
    public FinancialTransactionResponse rejectTransaction(Long id, String comment, User approver) {
        log.info("‚ùå ÌöåÍ≥Ñ Í±∞Îûò Í±∞Î∂Ä: ID={}, Í±∞Î∂ÄÏûê={}", id, approver.getEmail());
        
        // ÏàòÌçºÏñ¥ÎìúÎØºÎßå Í±∞Î∂Ä Í∞ÄÎä•
        if (!UserRole.HQ_MASTER.equals(approver.getRole())) {
            throw new RuntimeException("Í±∞Îûò Í±∞Î∂Ä Í∂åÌïúÏù¥ ÏóÜÏäµÎãàÎã§.");
        }
        
        FinancialTransaction transaction = financialTransactionRepository.findById(id)
                .orElseThrow(() -> new RuntimeException("Í±∞ÎûòÎ•º Ï∞æÏùÑ Ïàò ÏóÜÏäµÎãàÎã§: " + id));
        
        if (!transaction.isApprovable()) {
            throw new RuntimeException("Í±∞Î∂Ä Í∞ÄÎä•Ìïú ÏÉÅÌÉúÍ∞Ä ÏïÑÎãôÎãàÎã§.");
        }
        
        transaction.reject(approver, comment);
        FinancialTransaction savedTransaction = financialTransactionRepository.save(transaction);
        
        log.info("‚ùå ÌöåÍ≥Ñ Í±∞Îûò Í±∞Î∂Ä ÏôÑÎ£å: ID={}", savedTransaction.getId());
        return convertToResponse(savedTransaction);
    }
    
    @Override
    @Transactional(readOnly = true)
    public FinancialDashboardResponse getFinancialDashboard(LocalDate startDate, LocalDate endDate) {
        log.info("üìä Ïû¨Î¨¥ ÎåÄÏãúÎ≥¥Îìú Îç∞Ïù¥ÌÑ∞ Ï°∞Ìöå: {} ~ {}", startDate, endDate);
        
        // Í∏∞Î≥∏ ÌÜµÍ≥Ñ
        BigDecimal totalIncome = getTotalIncome(startDate, endDate);
        BigDecimal totalExpense = getTotalExpense(startDate, endDate);
        BigDecimal netProfit = totalIncome.subtract(totalExpense);
        
        // ÏäπÏù∏ ÎåÄÍ∏∞ Í±¥Ïàò
        Long pendingCount = financialTransactionRepository.countPendingApprovals();
        
        // ÏõîÎ≥Ñ Îç∞Ïù¥ÌÑ∞
        List<FinancialDashboardResponse.MonthlyFinancialData> monthlyData = getMonthlyFinancialData(startDate, endDate);
        
        // Ïπ¥ÌÖåÍ≥†Î¶¨Î≥Ñ Îç∞Ïù¥ÌÑ∞
        List<FinancialDashboardResponse.CategoryFinancialData> incomeByCategory = getIncomeByCategory(startDate, endDate);
        List<FinancialDashboardResponse.CategoryFinancialData> expenseByCategory = getExpenseByCategory(startDate, endDate);
        
        // ÏµúÍ∑º Í±∞Îûò ÎÇ¥Ïó≠
        List<FinancialTransactionResponse> recentTransactions = financialTransactionRepository
                .findRecentTransactions(Pageable.ofSize(10))
                .stream()
                .map(this::convertToResponse)
                .collect(Collectors.toList());
        
        // Í∏âÏó¨ Í¥ÄÎ†® Îç∞Ïù¥ÌÑ∞
        FinancialDashboardResponse.SalaryFinancialData salaryData = getSalaryFinancialData();
        
        // ERP Í¥ÄÎ†® Îç∞Ïù¥ÌÑ∞
        FinancialDashboardResponse.ErpFinancialData erpData = getErpFinancialData();
        
        // Í≤∞Ï†ú Í¥ÄÎ†® Îç∞Ïù¥ÌÑ∞
        FinancialDashboardResponse.PaymentFinancialData paymentData = getPaymentFinancialData();
        
        // Ï¥ù ÏÑ∏Í∏à Í≥ÑÏÇ∞
        BigDecimal totalTaxAmount = getTotalTaxAmount(startDate, endDate);
        
        return FinancialDashboardResponse.builder()
                .totalIncome(totalIncome)
                .totalExpense(totalExpense)
                .netProfit(netProfit)
                .totalTaxAmount(totalTaxAmount)
                .monthlyData(monthlyData)
                .incomeByCategory(incomeByCategory)
                .expenseByCategory(expenseByCategory)
                .recentTransactions(recentTransactions)
                .pendingApprovalCount(pendingCount)
                .salaryData(salaryData)
                .erpData(erpData)
                .paymentData(paymentData)
                .build();
    }
    
    @Override
    @Transactional(readOnly = true)
    public BigDecimal getTotalIncome(LocalDate startDate, LocalDate endDate) {
        return financialTransactionRepository.sumIncomeByDateRange(startDate, endDate);
    }
    
    @Override
    @Transactional(readOnly = true)
    public BigDecimal getTotalExpense(LocalDate startDate, LocalDate endDate) {
        return financialTransactionRepository.sumExpenseByDateRange(startDate, endDate);
    }
    
    @Override
    @Transactional(readOnly = true)
    public BigDecimal getNetProfit(LocalDate startDate, LocalDate endDate) {
        return getTotalIncome(startDate, endDate).subtract(getTotalExpense(startDate, endDate));
    }
    
    /**
     * Ï¥ù ÏÑ∏Í∏à Í≥ÑÏÇ∞
     * 
     * @param startDate ÏãúÏûëÏùº
     * @param endDate Ï¢ÖÎ£åÏùº
     * @return Ï¥ù ÏÑ∏Í∏à Í∏àÏï°
     */
    @Transactional(readOnly = true)
    public BigDecimal getTotalTaxAmount(LocalDate startDate, LocalDate endDate) {
        try {
            log.info("üí∞ Ï¥ù ÏÑ∏Í∏à Í≥ÑÏÇ∞ ÏãúÏûë: {} ~ {}", startDate, endDate);
            
            // ÏÑ∏Í∏à Í¥ÄÎ†® Í±∞Îûò Ï°∞Ìöå (Í≥µÌÜµ ÏΩîÎìúÏóêÏÑú Ïπ¥ÌÖåÍ≥†Î¶¨Î™Ö Ï°∞Ìöå)
            String taxCategory = getSafeCodeName("FINANCIAL_CATEGORY", "TAX", "ÏÑ∏Í∏à");
            List<FinancialTransaction> taxTransactions = financialTransactionRepository
                    .findByCategoryAndIsDeletedFalse(taxCategory);
            
            // Í∏∞Í∞Ñ ÌïÑÌÑ∞ÎßÅ
            List<FinancialTransaction> filteredTaxTransactions = taxTransactions.stream()
                    .filter(t -> !t.getTransactionDate().isBefore(startDate) && !t.getTransactionDate().isAfter(endDate))
                    .collect(Collectors.toList());
            
            // Ï¥ù ÏÑ∏Í∏à Í∏àÏï° Í≥ÑÏÇ∞
            BigDecimal totalTaxAmount = filteredTaxTransactions.stream()
                    .map(FinancialTransaction::getAmount)
                    .reduce(BigDecimal.ZERO, BigDecimal::add);
            
            // Î∂ÄÍ∞ÄÏÑ∏ Î≥ÑÎèÑ Í≥ÑÏÇ∞ (Í≥µÌÜµ ÏΩîÎìúÏóêÏÑú Í≤∞Ï†ú Ïπ¥ÌÖåÍ≥†Î¶¨Î™Ö Ï°∞Ìöå)
            String paymentCategory = getSafeCodeName("FINANCIAL_CATEGORY", "PAYMENT", "Í≤∞Ï†ú");
            List<FinancialTransaction> paymentTransactions = financialTransactionRepository
                    .findByCategoryAndIsDeletedFalse(paymentCategory);
            
            BigDecimal totalVatAmount = paymentTransactions.stream()
                    .filter(t -> !t.getTransactionDate().isBefore(startDate) && !t.getTransactionDate().isAfter(endDate))
                    .filter(t -> t.getTaxAmount() != null)
                    .map(FinancialTransaction::getTaxAmount)
                    .reduce(BigDecimal.ZERO, BigDecimal::add);
            
            // Ï¥ù ÏÑ∏Í∏à = ÏßÅÏ†ë ÏÑ∏Í∏à + Î∂ÄÍ∞ÄÏÑ∏
            BigDecimal grandTotalTax = totalTaxAmount.add(totalVatAmount);
            
            log.info("‚úÖ Ï¥ù ÏÑ∏Í∏à Í≥ÑÏÇ∞ ÏôÑÎ£å - ÏßÅÏ†ë ÏÑ∏Í∏à: {}, Î∂ÄÍ∞ÄÏÑ∏: {}, Ï¥ù ÏÑ∏Í∏à: {}", 
                    totalTaxAmount, totalVatAmount, grandTotalTax);
            
            return grandTotalTax;
            
        } catch (Exception e) {
            log.error("‚ùå Ï¥ù ÏÑ∏Í∏à Í≥ÑÏÇ∞ Ï§ë Ïò§Î•ò Î∞úÏÉù: {}", e.getMessage(), e);
            return BigDecimal.ZERO;
        }
    }
    
    @Override
    @Transactional(readOnly = true)
    public List<FinancialDashboardResponse.CategoryFinancialData> getIncomeByCategory(LocalDate startDate, LocalDate endDate) {
        List<Object[]> results = financialTransactionRepository.getIncomeByCategory(startDate, endDate);
        return convertToCategoryFinancialData(results);
    }
    
    @Override
    @Transactional(readOnly = true)
    public List<FinancialDashboardResponse.CategoryFinancialData> getExpenseByCategory(LocalDate startDate, LocalDate endDate) {
        List<Object[]> results = financialTransactionRepository.getExpenseByCategory(startDate, endDate);
        return convertToCategoryFinancialData(results);
    }
    
    @Override
    @Transactional(readOnly = true)
    public List<FinancialDashboardResponse.MonthlyFinancialData> getMonthlyFinancialData(LocalDate startDate, LocalDate endDate) {
        List<Object[]> results = financialTransactionRepository.getMonthlyFinancialData(startDate, endDate);
        Map<String, FinancialDashboardResponse.MonthlyFinancialData> monthlyMap = new HashMap<>();
        
        for (Object[] row : results) {
            Integer year = (Integer) row[0];
            Integer month = (Integer) row[1];
            String type = (String) row[2];
            BigDecimal amount = (BigDecimal) row[3];
            
            String monthKey = year + "-" + String.format("%02d", month);
            
            FinancialDashboardResponse.MonthlyFinancialData data = monthlyMap.computeIfAbsent(monthKey, k -> 
                FinancialDashboardResponse.MonthlyFinancialData.builder()
                    .month(year + "ÎÖÑ " + month + "Ïõî")
                    .income(BigDecimal.ZERO)
                    .expense(BigDecimal.ZERO)
                    .netProfit(BigDecimal.ZERO)
                    .transactionCount(0)
                    .build()
            );
            
            if ("INCOME".equals(type)) {
                data.setIncome(data.getIncome().add(amount));
            } else if ("EXPENSE".equals(type)) {
                data.setExpense(data.getExpense().add(amount));
            }
            
            data.setNetProfit(data.getIncome().subtract(data.getExpense()));
        }
        
        return new ArrayList<>(monthlyMap.values());
    }
    
    // ÌäπÌôîÎêú Í±∞Îûò ÏÉùÏÑ± Î©îÏÑúÎìúÎì§
    
    @Override
    public FinancialTransactionResponse createSalaryTransaction(Long salaryCalculationId, String description) {
        SalaryCalculation salary = salaryCalculationRepository.findById(salaryCalculationId)
                .orElseThrow(() -> new RuntimeException("Í∏âÏó¨ Í≥ÑÏÇ∞ÏùÑ Ï∞æÏùÑ Ïàò ÏóÜÏäµÎãàÎã§: " + salaryCalculationId));
        
        // Í≥µÌÜµ ÏΩîÎìúÏóêÏÑú Ïπ¥ÌÖåÍ≥†Î¶¨ Ï°∞Ìöå
        String expenseType = getSafeCodeName("TRANSACTION_TYPE", "EXPENSE", "EXPENSE");
        String salaryCategory = getSafeCodeName("FINANCIAL_CATEGORY", "SALARY", "Í∏âÏó¨");
        String consultantSalarySubcategory = getSafeCodeName("FINANCIAL_SUBCATEGORY", "CONSULTANT_SALARY", "ÏÉÅÎã¥ÏÇ¨Í∏âÏó¨");
        String salaryEntityType = getSafeCodeName("ENTITY_TYPE", "SALARY", "SALARY");
        
        FinancialTransactionRequest request = FinancialTransactionRequest.builder()
                .transactionType(expenseType)
                .category(salaryCategory)
                .subcategory(consultantSalarySubcategory)
                .amount(salary.getTotalSalary())
                .description(description != null ? description : "ÏÉÅÎã¥ÏÇ¨ Í∏âÏó¨ ÏßÄÍ∏â")
                .transactionDate(salary.getPayDate())
                .relatedEntityId(salaryCalculationId)
                .relatedEntityType(salaryEntityType)
                .taxIncluded(false)
                .taxAmount(salary.getTaxAmount())
                .amountBeforeTax(salary.getTotalSalary())
                .build();
        
        return createTransaction(request, null); // ÏãúÏä§ÌÖú ÏûêÎèô ÏÉùÏÑ±
    }
    
    @Override
    public FinancialTransactionResponse createPurchaseTransaction(Long purchaseRequestId, String description) {
        PurchaseRequest purchase = purchaseRequestRepository.findById(purchaseRequestId)
                .orElseThrow(() -> new RuntimeException("Íµ¨Îß§ ÏöîÏ≤≠ÏùÑ Ï∞æÏùÑ Ïàò ÏóÜÏäµÎãàÎã§: " + purchaseRequestId));
        
        // Í≥µÌÜµ ÏΩîÎìúÏóêÏÑú Ïπ¥ÌÖåÍ≥†Î¶¨ Ï°∞Ìöå
        String expenseType = getSafeCodeName("TRANSACTION_TYPE", "EXPENSE", "EXPENSE");
        String purchaseCategory = getSafeCodeName("FINANCIAL_CATEGORY", "PURCHASE", "Íµ¨Îß§");
        String equipmentPurchaseSubcategory = getSafeCodeName("FINANCIAL_SUBCATEGORY", "EQUIPMENT_PURCHASE", "ÎπÑÌíàÍµ¨Îß§");
        String purchaseEntityType = getSafeCodeName("ENTITY_TYPE", "PURCHASE", "PURCHASE");
        
        FinancialTransactionRequest request = FinancialTransactionRequest.builder()
                .transactionType(expenseType)
                .category(purchaseCategory)
                .subcategory(equipmentPurchaseSubcategory)
                .amount(purchase.getTotalAmount())
                .description(description != null ? description : purchase.getReason())
                .transactionDate(purchase.getCreatedAt().toLocalDate())
                .relatedEntityId(purchaseRequestId)
                .relatedEntityType(purchaseEntityType)
                .taxIncluded(true)
                .build();
        
        return createTransaction(request, null); // ÏãúÏä§ÌÖú ÏûêÎèô ÏÉùÏÑ±
    }
    
    @Override
    public FinancialTransactionResponse createPaymentTransaction(Long paymentId, String description, String category, String subcategory) {
        Payment payment = paymentRepository.findById(paymentId)
                .orElseThrow(() -> new RuntimeException("Í≤∞Ï†úÎ•º Ï∞æÏùÑ Ïàò ÏóÜÏäµÎãàÎã§: " + paymentId));
        
        // Î∂ÄÍ∞ÄÏÑ∏ Í≥ÑÏÇ∞ (Í≤∞Ï†ú Í∏àÏï°ÏùÄ Î∂ÄÍ∞ÄÏÑ∏ Ìè¨Ìï®)
        com.mindgarden.consultation.util.TaxCalculationUtil.TaxCalculationResult taxResult = 
            com.mindgarden.consultation.util.TaxCalculationUtil.calculateTaxFromPayment(payment.getAmount());
        
        // Í≥µÌÜµ ÏΩîÎìúÏóêÏÑú Ïπ¥ÌÖåÍ≥†Î¶¨ Ï°∞Ìöå
        String incomeType = getSafeCodeName("TRANSACTION_TYPE", "INCOME", "INCOME");
        String paymentCategory = getSafeCodeName("FINANCIAL_CATEGORY", "PAYMENT", "Í≤∞Ï†ú");
        String consultationFeeSubcategory = getSafeCodeName("FINANCIAL_SUBCATEGORY", "CONSULTATION_FEE", "ÏÉÅÎã¥Î£å");
        String paymentEntityType = getSafeCodeName("ENTITY_TYPE", "PAYMENT", "PAYMENT");
        
        FinancialTransactionRequest request = FinancialTransactionRequest.builder()
                .transactionType(incomeType)
                .category(category != null ? category : paymentCategory)
                .subcategory(subcategory != null ? subcategory : consultationFeeSubcategory)
                .amount(payment.getAmount()) // Î∂ÄÍ∞ÄÏÑ∏ Ìè¨Ìï® Í∏àÏï°
                .amountBeforeTax(taxResult.getAmountExcludingTax()) // Î∂ÄÍ∞ÄÏÑ∏ Ï†úÏô∏ Í∏àÏï°
                .taxAmount(taxResult.getVatAmount()) // Î∂ÄÍ∞ÄÏÑ∏ Í∏àÏï°
                .description(description != null ? description : payment.getDescription())
                .transactionDate(payment.getCreatedAt().toLocalDate())
                .relatedEntityId(paymentId)
                .relatedEntityType(paymentEntityType)
                .taxIncluded(true)
                .build();
        
        return createTransaction(request, null); // ÏãúÏä§ÌÖú ÏûêÎèô ÏÉùÏÑ±
    }
    
    @Override
    public FinancialTransactionResponse createRentTransaction(BigDecimal amount, LocalDate transactionDate, String description) {
        // Í≥µÌÜµ ÏΩîÎìúÏóêÏÑú Ïπ¥ÌÖåÍ≥†Î¶¨ Ï°∞Ìöå
        String expenseType = getSafeCodeName("TRANSACTION_TYPE", "EXPENSE", "EXPENSE");
        String rentCategory = getSafeCodeName("FINANCIAL_CATEGORY", "RENT", "ÏûÑÎåÄÎ£å");
        String officeRentSubcategory = getSafeCodeName("FINANCIAL_SUBCATEGORY", "OFFICE_RENT", "ÏÇ¨Î¨¥Ïã§ÏûÑÎåÄÎ£å");
        
        FinancialTransactionRequest request = FinancialTransactionRequest.builder()
                .transactionType(expenseType)
                .category(rentCategory)
                .subcategory(officeRentSubcategory)
                .amount(amount)
                .description(description != null ? description : "ÏÇ¨Î¨¥Ïã§ ÏûÑÎåÄÎ£å")
                .transactionDate(transactionDate)
                .taxIncluded(false)
                .build();
        
        return createTransaction(request, null); // ÏãúÏä§ÌÖú ÏûêÎèô ÏÉùÏÑ±
    }
    
    @Override
    public FinancialTransactionResponse createManagementFeeTransaction(BigDecimal amount, LocalDate transactionDate, String description) {
        // Í≥µÌÜµ ÏΩîÎìúÏóêÏÑú Ïπ¥ÌÖåÍ≥†Î¶¨ Ï°∞Ìöå
        String expenseType = getSafeCodeName("TRANSACTION_TYPE", "EXPENSE", "EXPENSE");
        String managementFeeCategory = getSafeCodeName("FINANCIAL_CATEGORY", "MANAGEMENT_FEE", "Í¥ÄÎ¶¨ÎπÑ");
        String officeManagementFeeSubcategory = getSafeCodeName("FINANCIAL_SUBCATEGORY", "OFFICE_MANAGEMENT_FEE", "ÏÇ¨Î¨¥Ïã§Í¥ÄÎ¶¨ÎπÑ");
        
        FinancialTransactionRequest request = FinancialTransactionRequest.builder()
                .transactionType(expenseType)
                .category(managementFeeCategory)
                .subcategory(officeManagementFeeSubcategory)
                .amount(amount)
                .description(description != null ? description : "ÏÇ¨Î¨¥Ïã§ Í¥ÄÎ¶¨ÎπÑ")
                .transactionDate(transactionDate)
                .taxIncluded(false)
                .build();
        
        return createTransaction(request, null); // ÏãúÏä§ÌÖú ÏûêÎèô ÏÉùÏÑ±
    }
    
    @Override
    public FinancialTransactionResponse createTaxTransaction(BigDecimal amount, LocalDate transactionDate, String description) {
        // Í≥µÌÜµ ÏΩîÎìúÏóêÏÑú Ïπ¥ÌÖåÍ≥†Î¶¨ Ï°∞Ìöå
        String expenseType = getSafeCodeName("TRANSACTION_TYPE", "EXPENSE", "EXPENSE");
        String taxCategory = getSafeCodeName("FINANCIAL_CATEGORY", "TAX", "ÏÑ∏Í∏à");
        String corporateTaxSubcategory = getSafeCodeName("FINANCIAL_SUBCATEGORY", "CORPORATE_TAX", "Î≤ïÏù∏ÏÑ∏");
        
        FinancialTransactionRequest request = FinancialTransactionRequest.builder()
                .transactionType(expenseType)
                .category(taxCategory)
                .subcategory(corporateTaxSubcategory)
                .amount(amount)
                .description(description != null ? description : "Î≤ïÏù∏ÏÑ∏")
                .transactionDate(transactionDate)
                .taxIncluded(false)
                .build();
        
        return createTransaction(request, null); // ÏãúÏä§ÌÖú ÏûêÎèô ÏÉùÏÑ±
    }
    
    // Ìó¨Ìçº Î©îÏÑúÎìúÎì§
    
    private FinancialTransactionResponse convertToResponse(FinancialTransaction transaction) {
        return FinancialTransactionResponse.builder()
                .id(transaction.getId())
                .transactionType(transaction.getTransactionType().name())
                .transactionTypeDisplayName(transaction.getTransactionType().getDisplayName())
                .category(transaction.getCategory())
                .subcategory(transaction.getSubcategory())
                .amount(transaction.getAmount())
                .description(transaction.getDescription())
                .transactionDate(transaction.getTransactionDate())
                .status(transaction.getStatus().name())
                .statusDisplayName(transaction.getStatus().getDisplayName())
                .approverName(transaction.getApprover() != null ? transaction.getApprover().getName() : null)
                .approvedAt(transaction.getApprovedAt())
                .approvalComment(transaction.getApprovalComment())
                .relatedEntityId(transaction.getRelatedEntityId())
                .relatedEntityType(transaction.getRelatedEntityType())
                .department(transaction.getDepartment())
                .projectCode(transaction.getProjectCode())
                .branchCode(transaction.getBranchCode())
                .taxIncluded(transaction.getTaxIncluded())
                .taxAmount(transaction.getTaxAmount())
                .amountBeforeTax(transaction.getAmountBeforeTax())
                .remarks(transaction.getRemarks())
                .createdAt(transaction.getCreatedAt())
                .updatedAt(transaction.getUpdatedAt())
                .build();
    }
    
    private List<FinancialDashboardResponse.CategoryFinancialData> convertToCategoryFinancialData(List<Object[]> results) {
        // Ï¥ù Í∏àÏï° Í≥ÑÏÇ∞ (ÎπÑÏú® Í≥ÑÏÇ∞ÏùÑ ÏúÑÌï¥)
        BigDecimal totalAmount = results.stream()
                .map(row -> (BigDecimal) row[1])
                .reduce(BigDecimal.ZERO, BigDecimal::add);
        
        return results.stream()
                .map(row -> {
                    String category = (String) row[0];
                    BigDecimal amount = (BigDecimal) row[1];
                    Long count = ((Number) row[2]).longValue();
                    
                    // ÎπÑÏú® Í≥ÑÏÇ∞
                    String percentage = calculatePercentage(amount, totalAmount);
                    
                    return FinancialDashboardResponse.CategoryFinancialData.builder()
                            .category(category)
                            .amount(amount)
                            .transactionCount(count.intValue())
                            .percentage(percentage)
                            .build();
                })
                .collect(Collectors.toList());
    }
    
    /**
     * ÎπÑÏú® Í≥ÑÏÇ∞ Ìó¨Ìçº Î©îÏÑúÎìú
     * 
     * @param amount Í∞úÎ≥Ñ Í∏àÏï°
     * @param totalAmount Ï¥ù Í∏àÏï°
     * @return ÎπÑÏú® Î¨∏ÏûêÏó¥ (Ïòà: "25.5%")
     */
    private String calculatePercentage(BigDecimal amount, BigDecimal totalAmount) {
        if (totalAmount == null || totalAmount.compareTo(BigDecimal.ZERO) == 0) {
            return "0%";
        }
        
        try {
            // ÎπÑÏú® Í≥ÑÏÇ∞: (Í∞úÎ≥Ñ Í∏àÏï° / Ï¥ù Í∏àÏï°) * 100
            BigDecimal percentage = amount
                    .divide(totalAmount, 4, RoundingMode.HALF_UP)
                    .multiply(BigDecimal.valueOf(100));
            
            // ÏÜåÏàòÏ†ê 1ÏûêÎ¶¨ÍπåÏßÄ Î∞òÏò¨Î¶º
            percentage = percentage.setScale(1, RoundingMode.HALF_UP);
            
            return percentage.toString() + "%";
            
        } catch (Exception e) {
            log.warn("ÎπÑÏú® Í≥ÑÏÇ∞ Ï§ë Ïò§Î•ò Î∞úÏÉù: amount={}, totalAmount={}, error={}", 
                    amount, totalAmount, e.getMessage());
            return "0%";
        }
    }
    
    private FinancialDashboardResponse.SalaryFinancialData getSalaryFinancialData() {
        // Í∏âÏó¨ Í¥ÄÎ†® ÌÜµÍ≥Ñ Îç∞Ïù¥ÌÑ∞ Ï°∞Ìöå Î°úÏßÅ Íµ¨ÌòÑ
        try {
            // Í∏âÏó¨ Í¥ÄÎ†® Í±∞Îûò Ï°∞Ìöå (Í≥µÌÜµ ÏΩîÎìúÏóêÏÑú Í∏âÏó¨ Ïπ¥ÌÖåÍ≥†Î¶¨Î™Ö Ï°∞Ìöå)
            String salaryCategory = getSafeCodeName("FINANCIAL_CATEGORY", "SALARY", "Í∏âÏó¨");
            List<FinancialTransaction> salaryTransactions = financialTransactionRepository
                    .findByCategoryAndIsDeletedFalse(salaryCategory);
            
            // Ï¥ù Í∏âÏó¨ ÏßÄÍ∏âÏï° Í≥ÑÏÇ∞
            BigDecimal totalSalaryPaid = salaryTransactions.stream()
                    .filter(t -> "INCOME".equals(t.getTransactionType().name()))
                    .map(FinancialTransaction::getAmount)
                    .reduce(BigDecimal.ZERO, BigDecimal::add);
            
            // Ï¥ù ÏÑ∏Í∏à Í≥µÏ†úÏï° Í≥ÑÏÇ∞ (Í≥µÌÜµ ÏΩîÎìúÏóêÏÑú ÏÑ∏Í∏à Ïπ¥ÌÖåÍ≥†Î¶¨Î™Ö Ï°∞Ìöå)
            String taxCategory = getSafeCodeName("FINANCIAL_CATEGORY", "TAX", "ÏÑ∏Í∏à");
            BigDecimal totalTaxWithheld = salaryTransactions.stream()
                    .filter(t -> taxCategory.equals(t.getCategory()))
                    .map(FinancialTransaction::getAmount)
                    .reduce(BigDecimal.ZERO, BigDecimal::add);
            
            // ÏÉÅÎã¥ÏÇ¨ Ïàò Ï°∞Ìöå (ÏûÑÏãúÎ°ú Í∏∞Î≥∏Í∞í ÏÇ¨Ïö©)
            long consultantCount = 5; // TODO: Ïã§Ï†ú ÏÉÅÎã¥ÏÇ¨ Ïàò Ï°∞Ìöå Î°úÏßÅ Íµ¨ÌòÑ
            
            // ÌèâÍ∑† Í∏âÏó¨ Í≥ÑÏÇ∞
            BigDecimal averageSalary = consultantCount > 0 ? 
                    totalSalaryPaid.divide(BigDecimal.valueOf(consultantCount), 2, RoundingMode.HALF_UP) : 
                    BigDecimal.ZERO;
            
            // Îì±Í∏âÎ≥Ñ Í∏âÏó¨ ÌÜµÍ≥Ñ (ÏûÑÏãúÎ°ú Í∏∞Î≥∏Í∞í ÏÇ¨Ïö©)
            List<FinancialDashboardResponse.SalaryByGrade> salaryByGrade = new ArrayList<>();
            // TODO: Ïã§Ï†ú Îì±Í∏âÎ≥Ñ Í∏âÏó¨ ÌÜµÍ≥Ñ Ï°∞Ìöå Î°úÏßÅ Íµ¨ÌòÑ
            
            log.info("‚úÖ Í∏âÏó¨ ÌÜµÍ≥Ñ Îç∞Ïù¥ÌÑ∞ Ï°∞Ìöå ÏôÑÎ£å - Ï¥ù Í∏âÏó¨: {}, ÏÉÅÎã¥ÏÇ¨ Ïàò: {}, ÌèâÍ∑† Í∏âÏó¨: {}", 
                    totalSalaryPaid, consultantCount, averageSalary);
            
            return FinancialDashboardResponse.SalaryFinancialData.builder()
                    .totalSalaryPaid(totalSalaryPaid)
                    .totalTaxWithheld(totalTaxWithheld)
                    .consultantCount((int) consultantCount)
                    .averageSalary(averageSalary)
                    .salaryByGrade(salaryByGrade)
                    .build();
                    
        } catch (Exception e) {
            log.error("‚ùå Í∏âÏó¨ ÌÜµÍ≥Ñ Îç∞Ïù¥ÌÑ∞ Ï°∞Ìöå Ï§ë Ïò§Î•ò Î∞úÏÉù: {}", e.getMessage(), e);
            
            // Ïò§Î•ò Î∞úÏÉù Ïãú Í∏∞Î≥∏Í∞í Î∞òÌôò
            return FinancialDashboardResponse.SalaryFinancialData.builder()
                    .totalSalaryPaid(BigDecimal.ZERO)
                    .totalTaxWithheld(BigDecimal.ZERO)
                    .consultantCount(0)
                    .averageSalary(BigDecimal.ZERO)
                    .salaryByGrade(new ArrayList<>())
                    .build();
        }
    }
    
    private FinancialDashboardResponse.ErpFinancialData getErpFinancialData() {
        // ERP Í¥ÄÎ†® ÌÜµÍ≥Ñ Îç∞Ïù¥ÌÑ∞ Ï°∞Ìöå Î°úÏßÅ Íµ¨ÌòÑ
        try {
            // ERP Í¥ÄÎ†® Í±∞Îûò Ï°∞Ìöå (Í≥µÌÜµ ÏΩîÎìúÏóêÏÑú Ïπ¥ÌÖåÍ≥†Î¶¨Î™Ö Ï°∞Ìöå)
            String purchaseCategory = getSafeCodeName("FINANCIAL_CATEGORY", "PURCHASE", "Íµ¨Îß§");
            String budgetCategory = getSafeCodeName("FINANCIAL_CATEGORY", "BUDGET", "ÏòàÏÇ∞");
            List<FinancialTransaction> purchaseTransactions = financialTransactionRepository
                    .findByCategoryAndIsDeletedFalse(purchaseCategory);
            List<FinancialTransaction> budgetTransactions = financialTransactionRepository
                    .findByCategoryAndIsDeletedFalse(budgetCategory);
            
            // Ï¥ù Íµ¨Îß§ Í∏àÏï° Í≥ÑÏÇ∞
            BigDecimal totalPurchaseAmount = purchaseTransactions.stream()
                    .map(FinancialTransaction::getAmount)
                    .reduce(BigDecimal.ZERO, BigDecimal::add);
            
            // Ï¥ù ÏòàÏÇ∞ Í≥ÑÏÇ∞
            BigDecimal totalBudget = budgetTransactions.stream()
                    .filter(t -> "INCOME".equals(t.getTransactionType().name()))
                    .map(FinancialTransaction::getAmount)
                    .reduce(BigDecimal.ZERO, BigDecimal::add);
            
            // ÏÇ¨Ïö©Îêú ÏòàÏÇ∞ Í≥ÑÏÇ∞
            BigDecimal usedBudget = budgetTransactions.stream()
                    .filter(t -> "EXPENSE".equals(t.getTransactionType().name()))
                    .map(FinancialTransaction::getAmount)
                    .reduce(BigDecimal.ZERO, BigDecimal::add);
            
            // ÏûîÏó¨ ÏòàÏÇ∞ Í≥ÑÏÇ∞
            BigDecimal remainingBudget = totalBudget.subtract(usedBudget);
            
            // ÎåÄÍ∏∞ Ï§ëÏù∏ ÏöîÏ≤≠ Ïàò (Ïã§Ï†ú Íµ¨ÌòÑÏóêÏÑúÎäî PurchaseRequest ÏóîÌã∞Ìã∞ Ï°∞Ìöå ÌïÑÏöî)
            int pendingRequests = 0; // TODO: PurchaseRequestRepositoryÏóêÏÑú Ï°∞Ìöå
            
            // ÏäπÏù∏Îêú ÏöîÏ≤≠ Ïàò (Ïã§Ï†ú Íµ¨ÌòÑÏóêÏÑúÎäî PurchaseRequest ÏóîÌã∞Ìã∞ Ï°∞Ìöå ÌïÑÏöî)
            int approvedRequests = 0; // TODO: PurchaseRequestRepositoryÏóêÏÑú Ï°∞Ìöå
            
            // Ïπ¥ÌÖåÍ≥†Î¶¨Î≥Ñ ÏòàÏÇ∞ ÌÜµÍ≥Ñ
            List<FinancialDashboardResponse.BudgetByCategory> budgetByCategory = budgetTransactions.stream()
                    .collect(Collectors.groupingBy(
                            FinancialTransaction::getCategory,
                            Collectors.reducing(BigDecimal.ZERO, 
                                    FinancialTransaction::getAmount, 
                                    BigDecimal::add)
                    ))
                    .entrySet().stream()
                    .map(entry -> FinancialDashboardResponse.BudgetByCategory.builder()
                            .category(entry.getKey())
                            .totalBudget(entry.getValue())
                            .usedBudget(BigDecimal.ZERO) // TODO: Ïã§Ï†ú ÏÇ¨Ïö©Îüâ Í≥ÑÏÇ∞
                            .remainingBudget(entry.getValue())
                            .build())
                    .collect(Collectors.toList());
            
            log.info("‚úÖ ERP ÌÜµÍ≥Ñ Îç∞Ïù¥ÌÑ∞ Ï°∞Ìöå ÏôÑÎ£å - Ï¥ù Íµ¨Îß§: {}, Ï¥ù ÏòàÏÇ∞: {}, ÏÇ¨Ïö© ÏòàÏÇ∞: {}, ÏûîÏó¨ ÏòàÏÇ∞: {}", 
                    totalPurchaseAmount, totalBudget, usedBudget, remainingBudget);
            
            return FinancialDashboardResponse.ErpFinancialData.builder()
                    .totalPurchaseAmount(totalPurchaseAmount)
                    .totalBudget(totalBudget)
                    .usedBudget(usedBudget)
                    .remainingBudget(remainingBudget)
                    .pendingRequests(pendingRequests)
                    .approvedRequests(approvedRequests)
                    .budgetByCategory(budgetByCategory)
                    .build();
                    
        } catch (Exception e) {
            log.error("‚ùå ERP ÌÜµÍ≥Ñ Îç∞Ïù¥ÌÑ∞ Ï°∞Ìöå Ï§ë Ïò§Î•ò Î∞úÏÉù: {}", e.getMessage(), e);
            
            // Ïò§Î•ò Î∞úÏÉù Ïãú Í∏∞Î≥∏Í∞í Î∞òÌôò
            return FinancialDashboardResponse.ErpFinancialData.builder()
                    .totalPurchaseAmount(BigDecimal.ZERO)
                    .totalBudget(BigDecimal.ZERO)
                    .usedBudget(BigDecimal.ZERO)
                    .remainingBudget(BigDecimal.ZERO)
                    .pendingRequests(0)
                    .approvedRequests(0)
                    .budgetByCategory(new ArrayList<>())
                    .build();
        }
    }
    
    private FinancialDashboardResponse.PaymentFinancialData getPaymentFinancialData() {
        // Í≤∞Ï†ú Í¥ÄÎ†® ÌÜµÍ≥Ñ Îç∞Ïù¥ÌÑ∞ Ï°∞Ìöå Î°úÏßÅ Íµ¨ÌòÑ
        try {
            // Í≤∞Ï†ú Í¥ÄÎ†® Í±∞Îûò Ï°∞Ìöå (Í≥µÌÜµ ÏΩîÎìúÏóêÏÑú Ïπ¥ÌÖåÍ≥†Î¶¨Î™Ö Ï°∞Ìöå)
            String paymentCategory = getSafeCodeName("FINANCIAL_CATEGORY", "PAYMENT", "Í≤∞Ï†ú");
            List<FinancialTransaction> paymentTransactions = financialTransactionRepository
                    .findByCategoryAndIsDeletedFalse(paymentCategory);
            
            // Ï¥ù Í≤∞Ï†ú Í∏àÏï° Í≥ÑÏÇ∞
            BigDecimal totalPaymentAmount = paymentTransactions.stream()
                    .filter(t -> "INCOME".equals(t.getTransactionType().name()))
                    .map(FinancialTransaction::getAmount)
                    .reduce(BigDecimal.ZERO, BigDecimal::add);
            
            // Ï¥ù Í≤∞Ï†ú Í±¥Ïàò
            int totalPaymentCount = paymentTransactions.size();
            
            // Í≤∞Ï†ú ÏÉÅÌÉúÎ≥Ñ ÌÜµÍ≥Ñ (Ïã§Ï†ú Íµ¨ÌòÑÏóêÏÑúÎäî PaymentStatus ÏóîÌã∞Ìã∞ Ï°∞Ìöå ÌïÑÏöî)
            int pendingPayments = 0;   // TODO: PaymentStatus.PENDING Ï°∞Ìöå
            int completedPayments = 0; // TODO: PaymentStatus.COMPLETED Ï°∞Ìöå
            int failedPayments = 0;    // TODO: PaymentStatus.FAILED Ï°∞Ìöå
            
            // Í≤∞Ï†ú ÏàòÎã®Î≥Ñ ÌÜµÍ≥Ñ
            Map<String, BigDecimal> paymentByMethod = paymentTransactions.stream()
                    .collect(Collectors.groupingBy(
                            t -> t.getDescription() != null ? t.getDescription() : "UNKNOWN",
                            Collectors.reducing(BigDecimal.ZERO, 
                                    FinancialTransaction::getAmount, 
                                    BigDecimal::add)
                    ));
            
            // Í≤∞Ï†ú Ï†úÍ≥µÏóÖÏ≤¥Î≥Ñ ÌÜµÍ≥Ñ
            Map<String, BigDecimal> paymentByProvider = paymentTransactions.stream()
                    .collect(Collectors.groupingBy(
                            t -> t.getCategory() != null ? t.getCategory() : "UNKNOWN",
                            Collectors.reducing(BigDecimal.ZERO, 
                                    FinancialTransaction::getAmount, 
                                    BigDecimal::add)
                    ));
            
            log.info("‚úÖ Í≤∞Ï†ú ÌÜµÍ≥Ñ Îç∞Ïù¥ÌÑ∞ Ï°∞Ìöå ÏôÑÎ£å - Ï¥ù Í≤∞Ï†ú: {}, Ï¥ù Í±¥Ïàò: {}, ÎåÄÍ∏∞: {}, ÏôÑÎ£å: {}, Ïã§Ìå®: {}", 
                    totalPaymentAmount, totalPaymentCount, pendingPayments, completedPayments, failedPayments);
            
            return FinancialDashboardResponse.PaymentFinancialData.builder()
                    .totalPaymentAmount(totalPaymentAmount)
                    .totalPaymentCount(totalPaymentCount)
                    .pendingPayments(pendingPayments)
                    .completedPayments(completedPayments)
                    .failedPayments(failedPayments)
                    .paymentByMethod(paymentByMethod)
                    .paymentByProvider(paymentByProvider)
                    .build();
                    
        } catch (Exception e) {
            log.error("‚ùå Í≤∞Ï†ú ÌÜµÍ≥Ñ Îç∞Ïù¥ÌÑ∞ Ï°∞Ìöå Ï§ë Ïò§Î•ò Î∞úÏÉù: {}", e.getMessage(), e);
            
            // Ïò§Î•ò Î∞úÏÉù Ïãú Í∏∞Î≥∏Í∞í Î∞òÌôò
            return FinancialDashboardResponse.PaymentFinancialData.builder()
                    .totalPaymentAmount(BigDecimal.ZERO)
                    .totalPaymentCount(0)
                    .pendingPayments(0)
                    .completedPayments(0)
                    .failedPayments(0)
                    .paymentByMethod(new HashMap<>())
                    .paymentByProvider(new HashMap<>())
                    .build();
        }
    }
    
    @Override
    public Map<String, Object> getBranchFinancialData(String branchCode, LocalDate startDate, LocalDate endDate, 
                                                     String category, String transactionType) {
        try {
            log.info("üè¢ ÏßÄÏ†êÎ≥Ñ Ïû¨Î¨¥ Îç∞Ïù¥ÌÑ∞ Ï°∞Ìöå: ÏßÄÏ†ê={}, ÏãúÏûëÏùº={}, Ï¢ÖÎ£åÏùº={}, Ïπ¥ÌÖåÍ≥†Î¶¨={}, Ïú†Ìòï={}", 
                    branchCode, startDate, endDate, category, transactionType);
            
            // ÏßÄÏ†êÎ≥Ñ Í±∞Îûò ÎÇ¥Ïó≠ Ï°∞Ìöå (ÏÇ≠Ï†úÎêòÏßÄ ÏïäÏùÄ Í±∞ÎûòÎßå)
            List<FinancialTransaction> allTransactions = financialTransactionRepository.findByIsDeletedFalse();
            log.info("üîç Ï†ÑÏ≤¥ Í±∞Îûò ÎÇ¥Ïó≠ Ïàò: {}", allTransactions.size());
            
            List<FinancialTransaction> transactions = allTransactions
                    .stream()
                    .filter(t -> branchCode.equals(t.getBranchCode()))
                    .filter(t -> !startDate.isAfter(t.getTransactionDate()) && !endDate.isBefore(t.getTransactionDate()))
                    .filter(t -> category == null || category.isEmpty() || category.equals(t.getCategory()))
                    .filter(t -> transactionType == null || transactionType.isEmpty() || 
                            transactionType.equals(t.getTransactionType().name()))
                    .collect(Collectors.toList());
            
            log.info("üîç ÌïÑÌÑ∞ÎßÅÎêú Í±∞Îûò ÎÇ¥Ïó≠ Ïàò: {}, ÏßÄÏ†ê: {}, Í∏∞Í∞Ñ: {}~{}", 
                    transactions.size(), branchCode, startDate, endDate);
            
            // ÏàòÏùµ/ÏßÄÏ∂ú Í≥ÑÏÇ∞
            BigDecimal totalRevenue = transactions.stream()
                    .filter(t -> FinancialTransaction.TransactionType.INCOME.equals(t.getTransactionType()))
                    .map(FinancialTransaction::getAmount)
                    .reduce(BigDecimal.ZERO, BigDecimal::add);
            
            BigDecimal totalExpenses = transactions.stream()
                    .filter(t -> FinancialTransaction.TransactionType.EXPENSE.equals(t.getTransactionType()))
                    .map(FinancialTransaction::getAmount)
                    .reduce(BigDecimal.ZERO, BigDecimal::add);
            
            BigDecimal netProfit = totalRevenue.subtract(totalExpenses);
            
            // Í±∞Îûò ÎÇ¥Ïó≠ Î≥ÄÌôò
            List<Map<String, Object>> transactionList = transactions.stream()
                    .map(this::convertTransactionToMap)
                    .collect(Collectors.toList());
            
            // Ïπ¥ÌÖåÍ≥†Î¶¨Î≥Ñ Î∂ÑÏÑù
            Map<String, BigDecimal> categoryBreakdown = transactions.stream()
                    .collect(Collectors.groupingBy(
                            t -> t.getCategory() != null ? t.getCategory() : "Í∏∞ÌÉÄ",
                            Collectors.reducing(BigDecimal.ZERO, 
                                    FinancialTransaction::getAmount, 
                                    BigDecimal::add)
                    ));
            
            // ÏõîÎ≥Ñ ÌÜµÍ≥Ñ (Í∞ÑÎã®Ìïú ÌòïÌÉúÎ°ú)
            Map<String, BigDecimal> monthlyStats = transactions.stream()
                    .collect(Collectors.groupingBy(
                            t -> t.getTransactionDate().getYear() + "-" + 
                                 String.format("%02d", t.getTransactionDate().getMonthValue()),
                            Collectors.reducing(BigDecimal.ZERO, 
                                    FinancialTransaction::getAmount, 
                                    BigDecimal::add)
                    ));
            
            Map<String, Object> result = new HashMap<>();
            result.put("summary", Map.of(
                "totalRevenue", totalRevenue.longValue(),
                "totalExpenses", totalExpenses.longValue(),
                "netProfit", netProfit.longValue(),
                "transactionCount", transactions.size()
            ));
            result.put("transactions", transactionList);
            result.put("categoryBreakdown", categoryBreakdown);
            result.put("monthlyStats", monthlyStats);
            
            log.info("‚úÖ ÏßÄÏ†êÎ≥Ñ Ïû¨Î¨¥ Îç∞Ïù¥ÌÑ∞ Ï°∞Ìöå ÏôÑÎ£å: ÏßÄÏ†ê={}, ÏàòÏùµ={}, ÏßÄÏ∂ú={}, ÏàúÏù¥Ïùµ={}", 
                    branchCode, totalRevenue, totalExpenses, netProfit);
            
            return result;
            
        } catch (Exception e) {
            log.error("‚ùå ÏßÄÏ†êÎ≥Ñ Ïû¨Î¨¥ Îç∞Ïù¥ÌÑ∞ Ï°∞Ìöå Ïã§Ìå®: ÏßÄÏ†ê={}, Ïò§Î•ò={}", branchCode, e.getMessage(), e);
            
            // Ïò§Î•ò Ïãú Í∏∞Î≥∏Í∞í Î∞òÌôò
            Map<String, Object> result = new HashMap<>();
            result.put("summary", Map.of(
                "totalRevenue", 0L,
                "totalExpenses", 0L,
                "netProfit", 0L,
                "transactionCount", 0
            ));
            result.put("transactions", List.of());
            result.put("categoryBreakdown", Map.of());
            result.put("monthlyStats", Map.of());
            
            return result;
        }
    }
    
    /**
     * FinancialTransactionÏùÑ MapÏúºÎ°ú Î≥ÄÌôò
     */
    private Map<String, Object> convertTransactionToMap(FinancialTransaction transaction) {
        Map<String, Object> map = new HashMap<>();
        map.put("id", transaction.getId());
        map.put("date", transaction.getTransactionDate().toString());
        map.put("type", transaction.getTransactionType().name());
        map.put("category", transaction.getCategory());
        map.put("subcategory", transaction.getSubcategory());
        map.put("description", transaction.getDescription());
        map.put("amount", transaction.getAmount().longValue());
        map.put("status", transaction.getStatus() != null ? transaction.getStatus().name() : "UNKNOWN");
        return map;
    }
    
    @Override
    @Transactional(readOnly = true)
    public Page<FinancialTransactionResponse> getTransactionsByBranch(String branchCode, String transactionType, 
                                                                     String category, String startDate, String endDate, 
                                                                     Pageable pageable) {
        try {
            log.info("üè¢ ÏßÄÏ†êÎ≥Ñ Ïû¨Î¨¥ Í±∞Îûò Î™©Î°ù Ï°∞Ìöå: ÏßÄÏ†ê={}, Ïú†Ìòï={}, Ïπ¥ÌÖåÍ≥†Î¶¨={}, ÏãúÏûëÏùº={}, Ï¢ÖÎ£åÏùº={}", 
                    branchCode, transactionType, category, startDate, endDate);
            
            // Î™®Îì† Í±∞Îûò Ï°∞Ìöå ÌõÑ ÌïÑÌÑ∞ÎßÅ
            Page<FinancialTransaction> allTransactions = financialTransactionRepository
                    .findByIsDeletedFalseOrderByTransactionDateDescCreatedAtDesc(
                        org.springframework.data.domain.PageRequest.of(0, 10000)); // Îçî ÎßéÏùÄ Îç∞Ïù¥ÌÑ∞ Í∞ÄÏ†∏Ïò§Í∏∞
            
            log.info("üîç Ï†ÑÏ≤¥ Ïû¨Î¨¥ Í±∞Îûò Ï°∞Ìöå ÏôÑÎ£å: {}Í±¥", allTransactions.getTotalElements());
            
            // ÏßÄÏ†êÎ≥Ñ ÌïÑÌÑ∞ÎßÅ Ï†ÅÏö©
            List<FinancialTransaction> filteredTransactions = allTransactions.getContent().stream()
                    .filter(t -> {
                        // ÏßÄÏ†êÏΩîÎìú ÌïÑÌÑ∞ÎßÅ ÎîîÎ≤ÑÍπÖ
                        if (branchCode != null && !branchCode.isEmpty()) {
                            boolean matches = branchCode.equals(t.getBranchCode());
                            if (!matches) {
                                log.info("üîç ÏßÄÏ†êÏΩîÎìú Î∂àÏùºÏπò: ÏöîÏ≤≠={}, Í±∞Îûò={} (Í±∞ÎûòID={})", branchCode, t.getBranchCode(), t.getId());
                            } else {
                                log.info("‚úÖ ÏßÄÏ†êÏΩîÎìú ÏùºÏπò: ÏöîÏ≤≠={}, Í±∞Îûò={} (Í±∞ÎûòID={})", branchCode, t.getBranchCode(), t.getId());
                            }
                            return matches;
                        }
                        log.info("üîç ÏßÄÏ†êÏΩîÎìú ÌïÑÌÑ∞ÎßÅ ÏóÜÏùå - Î™®Îì† Í±∞Îûò Ìè¨Ìï®");
                        return true;
                    })
                    .filter(t -> {
                        // Í±∞Îûò Ïú†Ìòï ÌïÑÌÑ∞ÎßÅ
                        if (transactionType != null && !transactionType.isEmpty() && !"ALL".equals(transactionType)) {
                            return transactionType.equals(t.getTransactionType().name());
                        }
                        return true;
                    })
                    .filter(t -> {
                        // Ïπ¥ÌÖåÍ≥†Î¶¨ ÌïÑÌÑ∞ÎßÅ
                        if (category != null && !category.isEmpty() && !"ALL".equals(category)) {
                            return category.equals(t.getCategory());
                        }
                        return true;
                    })
                    .filter(t -> {
                        // ÎÇ†Ïßú Î≤îÏúÑ ÌïÑÌÑ∞ÎßÅ
                        if (startDate != null && !startDate.isEmpty()) {
                            LocalDate start = LocalDate.parse(startDate);
                            if (t.getTransactionDate().isBefore(start)) {
                                return false;
                            }
                        }
                        if (endDate != null && !endDate.isEmpty()) {
                            LocalDate end = LocalDate.parse(endDate);
                            if (t.getTransactionDate().isAfter(end)) {
                                return false;
                            }
                        }
                        return true;
                    })
                    .collect(Collectors.toList());
            
            log.info("üîç ÌïÑÌÑ∞ÎßÅ Í≤∞Í≥º: Ï†ÑÏ≤¥={}Í±¥, ÏßÄÏ†ê ÌïÑÌÑ∞ÎßÅ ÌõÑ={}Í±¥", allTransactions.getTotalElements(), filteredTransactions.size());
            
            // Ï≤òÏùå Î™á Í∞ú Í±∞ÎûòÏùò ÏßÄÏ†êÏΩîÎìú Ï∂úÎ†• (ÎîîÎ≤ÑÍπÖ)
            filteredTransactions.stream().limit(5).forEach(t -> 
                log.info("üìä Í±∞Îûò ÏÉòÌîå: ID={}, ÏßÄÏ†ê={}, Ïú†Ìòï={}, Í∏àÏï°={}", 
                    t.getId(), t.getBranchCode(), t.getTransactionType(), t.getAmount())
            );
            
            // ÌéòÏù¥Ïßï Ï≤òÎ¶¨
            int start = (int) pageable.getOffset();
            int end = Math.min((start + pageable.getPageSize()), filteredTransactions.size());
            List<FinancialTransaction> pageContent = filteredTransactions.subList(start, end);
            
            // FinancialTransactionResponseÎ°ú Î≥ÄÌôò
            List<FinancialTransactionResponse> responseContent = pageContent.stream()
                    .map(this::convertToResponse)
                    .collect(Collectors.toList());
            
            // Page Í∞ùÏ≤¥ ÏÉùÏÑ±
            Page<FinancialTransactionResponse> result = new org.springframework.data.domain.PageImpl<>(
                    responseContent, pageable, filteredTransactions.size());
            
            log.info("‚úÖ ÏßÄÏ†êÎ≥Ñ Ïû¨Î¨¥ Í±∞Îûò Ï°∞Ìöå ÏôÑÎ£å: ÏßÄÏ†ê={}, Ï†ÑÏ≤¥={}, ÌïÑÌÑ∞ÎßÅÌõÑ={}Í±¥", 
                    branchCode, allTransactions.getTotalElements(), filteredTransactions.size());
            
            return result;
            
        } catch (Exception e) {
            log.error("‚ùå ÏßÄÏ†êÎ≥Ñ Ïû¨Î¨¥ Í±∞Îûò Ï°∞Ìöå Ïã§Ìå®: ÏßÄÏ†ê={}, Ïò§Î•ò={}", branchCode, e.getMessage(), e);
            throw new RuntimeException("ÏßÄÏ†êÎ≥Ñ Ïû¨Î¨¥ Í±∞Îûò Ï°∞ÌöåÏóê Ïã§Ìå®ÌñàÏäµÎãàÎã§: " + e.getMessage());
        }
    }
    
    /**
     * ÏïàÏ†ÑÌïú Í≥µÌÜµ ÏΩîÎìúÎ™Ö Ï°∞Ìöå (Ïò§Î•ò Ïãú Í∏∞Î≥∏Í∞í Î∞òÌôò)
     * 
     * @param codeGroup ÏΩîÎìú Í∑∏Î£π
     * @param codeValue ÏΩîÎìú Í∞í
     * @param defaultValue Í∏∞Î≥∏Í∞í
     * @return ÏΩîÎìúÎ™Ö ÎòêÎäî Í∏∞Î≥∏Í∞í
     */
    private String getSafeCodeName(String codeGroup, String codeValue, String defaultValue) {
        try {
            String codeName = commonCodeService.getCodeName(codeGroup, codeValue);
            return codeName != null ? codeName : defaultValue;
        } catch (Exception e) {
            log.warn("Í≥µÌÜµ ÏΩîÎìú Ï°∞Ìöå Ïã§Ìå®, Í∏∞Î≥∏Í∞í ÏÇ¨Ïö©: {} - {} -> {}", codeGroup, codeValue, defaultValue);
            return defaultValue;
        }
    }
}
